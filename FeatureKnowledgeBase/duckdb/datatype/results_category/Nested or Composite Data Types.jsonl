{"index": 0, "HTML": ["https://duckdb.org/docs/sql/data_types/array"], "Title": ["Array"], "Feature": ["Array"], "Description": ["\n\n\nDocumentation\n/ SQL\n/ Data Types\n\n\n\n\n\nDark Mode\n\n\n1.1 (stable)\n\n\n\n1.1 (stable)\n\n1.0\n0.10\n\n\n\n\nArray Type\n", "An ARRAY column stores fixed-sized arrays. All fields in the column must have the same length and the same underlying type. Arrays are typically used to store arrays of numbers, but can contain any uniform data type, including ARRAY, LIST and STRUCT types.", "Arrays can be used to store vectors such as word embeddings or image embeddings.", "To store variable-length lists, use the LIST type. See the data types overview for a comparison between nested data types.", "Note\nThe ARRAY type in PostgreSQL allows variable-length fields. DuckDB's ARRAY type is fixed-length.\n", "\nCreating Arrays\n", "Arrays can be created using the array_value(expr, ...) function.", "Construct with the array_value function:", "SELECT array_value(1, 2, 3);\n", "You can always implicitly cast an array to a list (and use list functions, like list_extract, [i]):", "SELECT array_value(1, 2, 3)[2];\n", "You can cast from a list to an array (the dimensions have to match):", "SELECT [3, 2, 1]::INTEGER[3];\n", "Arrays can be nested:", "SELECT array_value(array_value(1, 2), array_value(3, 4), array_value(5, 6));\n", "Arrays can store structs:", "SELECT array_value({'a': 1, 'b': 2}, {'a': 3, 'b': 4});\n", "\nDefining an Array Field\n", "Arrays can be created using the \u27e8TYPE_NAME\u27e9[\u27e8LENGTH\u27e9] syntax. For example, to create an array field for 3 integers, run:", "CREATE TABLE array_table (id INTEGER, arr INTEGER[3]);\nINSERT INTO array_table VALUES (10, [1, 2, 3]), (20, [4, 5, 6]);\n", "\nRetrieving Values from Arrays\n", "Retrieving one or more values from an array can be accomplished using brackets and slicing notation, or through list functions like list_extract and array_extract. Using the example in Defining an Array Field.", "The following queries for extracting the second element of an array are equivalent:", "SELECT id, arr[1] AS element FROM array_table;\nSELECT id, list_extract(arr, 1) AS element FROM array_table;\nSELECT id, array_extract(arr, 1) AS element FROM array_table;\n", "\n\n\nid\nelement\n\n\n\n\n10\n1\n\n\n20\n4\n\n\n", "Using the slicing notation returns a LIST:", "SELECT id, arr[1:2] AS elements FROM array_table;\n", "\n\n\nid\nelements\n\n\n\n\n10\n[1, 2]\n\n\n20\n[4, 5]\n\n\n", "\nFunctions\n", "All LIST functions work with the ARRAY type. Additionally, several ARRAY-native functions are also supported.\nSee the ARRAY functions.", "\nExamples\n", "Create sample data:", "CREATE TABLE x (i INTEGER, v FLOAT[3]);\nCREATE TABLE y (i INTEGER, v FLOAT[3]);\nINSERT INTO x VALUES (1, array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT));\nINSERT INTO y VALUES (1, array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT));\n", "Compute cross product:", "SELECT array_cross_product(x.v, y.v)\nFROM x, y\nWHERE x.i = y.i;\n", "Compute cosine similarity:", "SELECT array_cosine_similarity(x.v, y.v)\nFROM x, y\nWHERE x.i = y.i;\n", "\nOrdering\n", "The ordering of ARRAY instances is defined using a lexicographical order. NULL values compare greater than all other values and are considered equal to each other.", "\nSee Also\n", "For more functions, see List Functions.", "\n\nAbout this page\n\nReport content issue\nEdit this page on GitHub\n\n\n"], "Examples": ["SELECT array_value(1, 2, 3);\n", "SELECT array_value(1, 2, 3)[2];\n", "SELECT [3, 2, 1]::INTEGER[3];\n", "SELECT array_value(array_value(1, 2), array_value(3, 4), array_value(5, 6));\n", "SELECT array_value({'a': 1, 'b': 2}, {'a': 3, 'b': 4});\n", "CREATE TABLE array_table (id INTEGER, arr INTEGER[3]);\nINSERT INTO array_table VALUES (10, [1, 2, 3]), (20, [4, 5, 6]);\n", "SELECT id, arr[1] AS element FROM array_table;\nSELECT id, list_extract(arr, 1) AS element FROM array_table;\nSELECT id, array_extract(arr, 1) AS element FROM array_table;\n", "SELECT id, arr[1:2] AS elements FROM array_table;\n", "CREATE TABLE x (i INTEGER, v FLOAT[3]);\nCREATE TABLE y (i INTEGER, v FLOAT[3]);\nINSERT INTO x VALUES (1, array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT));\nINSERT INTO y VALUES (1, array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT));\n", "SELECT array_cross_product(x.v, y.v)\nFROM x, y\nWHERE x.i = y.i;\n", "SELECT array_cosine_similarity(x.v, y.v)\nFROM x, y\nWHERE x.i = y.i;\n"], "Category": ["Nested or Composite Data Types"]}
{"index": 7, "HTML": ["https://duckdb.org/docs/sql/data_types/list"], "Title": ["List"], "Feature": ["List"], "Description": ["\n\n\nDocumentation\n/ SQL\n/ Data Types\n\n\n\n\n\nDark Mode\n\n\n1.1 (stable)\n\n\n\n1.1 (stable)\n\n1.0\n0.10\n0.9\n0.8\n0.7\n\n\n\n\nList Type\n", "A LIST column encodes lists of values. Fields in the column can have values with different lengths, but they must all have the same underlying type. LISTs are typically used to store arrays of numbers, but can contain any uniform data type, including other LISTs and STRUCTs.", "LISTs are similar to PostgreSQL's ARRAY type. DuckDB uses the LIST terminology, but some array_ functions are provided for PostgreSQL compatibility.", "See the data types overview for a comparison between nested data types.", "Note\nFor storing fixed-length lists, DuckDB uses the ARRAY type.\n", "\nCreating Lists\n", "Lists can be created using the list_value(expr, ...) function or the equivalent bracket notation [expr, ...]. The expressions can be constants or arbitrary expressions. To create a list from a table column, use the list aggregate function.", "List of integers:", "SELECT [1, 2, 3];\n", "List of strings with a NULL value:", "SELECT ['duck', 'goose', NULL, 'heron'];\n", "List of lists with NULL values:", "SELECT [['duck', 'goose', 'heron'], NULL, ['frog', 'toad'], []];\n", "Create a list with the list_value function:", "SELECT list_value(1, 2, 3);\n", "Create a table with an INTEGER list column and a VARCHAR list column:", "CREATE TABLE list_table (int_list INTEGER[], varchar_list VARCHAR[]);\n", "\nRetrieving from Lists\n", "Retrieving one or more values from a list can be accomplished using brackets and slicing notation, or through list functions like list_extract. Multiple equivalent functions are provided as aliases for compatibility with systems that refer to lists as arrays. For example, the function array_slice.", "Note\nWe wrap the list creation in parenthesis so that it happens first.\nThis is only needed in our basic examples here, not when working with a list column.\nFor example, this can't be parsed: SELECT ['a', 'b', 'c'][1].\n", "\n\n\nExample\nResult\n\n\n\n\nSELECT (['a', 'b', 'c'])[3]\n'c'\n\n\nSELECT (['a', 'b', 'c'])[-1]\n'c'\n\n\nSELECT (['a', 'b', 'c'])[2 + 1]\n'c'\n\n\nSELECT list_extract(['a', 'b', 'c'], 3)\n'c'\n\n\nSELECT (['a', 'b', 'c'])[1:2]\n['a', 'b']\n\n\nSELECT (['a', 'b', 'c'])[:2]\n['a', 'b']\n\n\nSELECT (['a', 'b', 'c'])[-2:]\n['b', 'c']\n\n\nSELECT list_slice(['a', 'b', 'c'], 2, 3)\n['b', 'c']\n\n\n", "\nComparison and Ordering\n", "The LIST type can be compared using all the comparison operators.\nThese comparisons can be used in logical expressions\nsuch as WHERE and HAVING clauses, and return BOOLEAN values.", "The LIST ordering is defined positionally using the following rules, where min_len = min(len(l1), len(l2)).", "\nEquality. l1 and l2 are equal, if for each i in [1, min_len]: l1[i] = l2[i].\nLess Than. For the first index i in [1, min_len] where l1[i] != l2[i]:\nIf l1[i] < l2[i], l1 is less than l2.\n", "NULL values are compared following PostgreSQL's semantics.\nLower nesting levels are used for tie-breaking.", "Here are some queries returning true for the comparison.", "SELECT [1, 2] < [1, 3] AS result;\n", "SELECT [[1], [2, 4, 5]] < [[2]] AS result;\n", "SELECT [ ] < [1] AS result;\n", "These queries return false.", "SELECT [ ] < [ ] AS result;\n", "SELECT [1, 2] < [1] AS result;\n", "These queries return NULL.", "SELECT [1, 2] < [1, NULL, 4] AS result;\n", "\nUpdating Lists\n", "Updates on lists are internally represented as an insert and a delete operation.\nTherefore, updating list values may lead to a duplicate key error on primary/unique keys.\nSee the following example:", "CREATE TABLE tbl (id INTEGER PRIMARY KEY, lst INTEGER[], comment VARCHAR);\nINSERT INTO tbl VALUES (1, [12, 34], 'asd');\nUPDATE tbl SET lst = [56, 78] WHERE id = 1;\n", "Constraint Error: Duplicate key \"id: 1\" violates primary key constraint.\nIf this is an unexpected constraint violation please double check with the known index limitations section in our documentation (https://duckdb.org/docs/sql/indexes).\n", "\nFunctions\n", "See List Functions.", "\n\nAbout this page\n\nReport content issue\nEdit this page on GitHub\n\n\n"], "Examples": ["SELECT [1, 2, 3];\n", "SELECT ['duck', 'goose', NULL, 'heron'];\n", "SELECT [['duck', 'goose', 'heron'], NULL, ['frog', 'toad'], []];\n", "SELECT list_value(1, 2, 3);\n", "CREATE TABLE list_table (int_list INTEGER[], varchar_list VARCHAR[]);\n", "SELECT [1, 2] < [1, 3] AS result;\n", "SELECT [[1], [2, 4, 5]] < [[2]] AS result;\n", "SELECT [ ] < [1] AS result;\n", "SELECT [ ] < [ ] AS result;\n", "SELECT [1, 2] < [1] AS result;\n", "SELECT [1, 2] < [1, NULL, 4] AS result;\n", "CREATE TABLE tbl (id INTEGER PRIMARY KEY, lst INTEGER[], comment VARCHAR);\nINSERT INTO tbl VALUES (1, [12, 34], 'asd');\nUPDATE tbl SET lst = [56, 78] WHERE id = 1;\n", "Constraint Error: Duplicate key \"id: 1\" violates primary key constraint.\nIf this is an unexpected constraint violation please double check with the known index limitations section in our documentation (https://duckdb.org/docs/sql/indexes).\n"], "Category": ["Nested or Composite Data Types"]}
{"index": 8, "HTML": ["https://duckdb.org/docs/sql/data_types/union"], "Title": ["Union"], "Feature": ["Union"], "Description": ["\n\n\nDocumentation\n/ SQL\n/ Data Types\n\n\n\n\n\nDark Mode\n\n\n1.1 (stable)\n\n\n\n1.1 (stable)\n\n1.0\n0.10\n0.9\n0.8\n0.7\n\n\n\n\nUnion Type\n", "A UNION type (not to be confused with the SQL UNION operator) is a nested type capable of holding one of multiple \u201calternative\u201d values, much like the union in C. The main difference being that these UNION types are tagged unions and thus always carry a discriminator \u201ctag\u201d which signals which alternative it is currently holding, even if the inner value itself is null. UNION types are thus more similar to C++17's std::variant, Rust's Enum or the \u201csum type\u201d present in most functional languages.", "UNION types must always have at least one member, and while they can contain multiple members of the same type, the tag names must be unique. UNION types can have at most 256 members.", "Under the hood, UNION types are implemented on top of STRUCT types, and simply keep the \u201ctag\u201d as the first entry.", "UNION values can be created with the union_value(tag := expr) function or by casting from a member type.", "\nExample\n", "Create a table with a UNION column:", "CREATE TABLE tbl1 (u UNION(num INTEGER, str VARCHAR));\nINSERT INTO tbl1 values (1), ('two'), (union_value(str := 'three'));\n", "Any type can be implicitly cast to a UNION containing the type. Any UNION can also be implicitly cast to another UNION if the source UNION members are a subset of the target's (if the cast is unambiguous).", "UNION uses the member types' VARCHAR cast functions when casting to VARCHAR:", "SELECT u FROM tbl1;\n", "\n\n\nu\n\n\n\n\n1\n\n\ntwo\n\n\nthree\n\n\n", "Select all the str members:", "SELECT union_extract(u, 'str') AS str\nFROM tbl1;\n", "\n\n\nstr\n\n\n\n\nNULL\n\n\ntwo\n\n\nthree\n\n\n", "Alternatively, you can use 'dot syntax' similarly to STRUCTs.", "SELECT u.str\nFROM tbl1;\n", "\n\n\nstr\n\n\n\n\nNULL\n\n\ntwo\n\n\nthree\n\n\n", "Select the currently active tag from the UNION as an ENUM.", "SELECT union_tag(u) AS t\nFROM tbl1;\n", "\n\n\nt\n\n\n\n\nnum\n\n\nstr\n\n\nstr\n\n\n", "\nUnion Casts\n", "Compared to other nested types, UNIONs allow a set of implicit casts to facilitate unintrusive and natural usage when working with their members as \u201csubtypes\u201d.\nHowever, these casts have been designed with two principles in mind, to avoid ambiguity and to avoid casts that could lead to loss of information. This prevents UNIONs from being completely \u201ctransparent\u201d, while still allowing UNION types to have a \u201csupertype\u201d relationship with their members.", "Thus UNION types can't be implicitly cast to any of their member types in general, since the information in the other members not matching the target type would be \u201clost\u201d. If you want to coerce a UNION into one of its members, you should use the union_extract function explicitly instead.", "The only exception to this is when casting a UNION to VARCHAR, in which case the members will all use their corresponding VARCHAR casts. Since everything can be cast to VARCHAR, this is \u201csafe\u201d in a sense.", "\nCasting to Unions\n", "A type can always be implicitly cast to a UNION if it can be implicitly cast to one of the UNION member types.", "\nIf there are multiple candidates, the built in implicit casting priority rules determine the target type. For example, a FLOAT \u2192 UNION(i INTEGER, v VARCHAR) cast will always cast the FLOAT to the INTEGER member before VARCHAR.\nIf the cast still is ambiguous, i.e., there are multiple candidates with the same implicit casting priority, an error is raised. This usually happens when the UNION contains multiple members of the same type, e.g., a FLOAT \u2192 UNION(i INTEGER, num INTEGER) is always ambiguous.\n", "So how do we disambiguate if we want to create a UNION with multiple members of the same type? By using the union_value function, which takes a keyword argument specifying the tag. For example, union_value(num := 2::INTEGER) will create a UNION with a single member of type INTEGER with the tag num. This can then be used to disambiguate in an explicit (or implicit, read on below!) UNION to UNION cast, like CAST(union_value(b := 2) AS UNION(a INTEGER, b INTEGER)).", "\nCasting between Unions\n", "UNION types can be cast between each other if the source type is a \u201csubset\u201d of the target type. In other words, all the tags in the source UNION must be present in the target UNION, and all the types of the matching tags must be implicitly castable between source and target. In essence, this means that UNION types are covariant with respect to their members.", "\n\n\nOk\nSource\nTarget\nComments\n\n\n\n\n\u2705\nUNION(a A, b B)\nUNION(a A, b B, c C)\n\u00a0\n\n\n\u2705\nUNION(a A, b B)\nUNION(a A, b C)\nif B can be implicitly cast to C\n\n\n\u274c\nUNION(a A, b B, c C)\nUNION(a A, b B)\n\u00a0\n\n\n\u274c\nUNION(a A, b B)\nUNION(a A, b C)\nif B can't be implicitly cast to C\n\n\n\u274c\nUNION(A, B, D)\nUNION(A, B, C)\n\u00a0\n\n\n", "\nComparison and Sorting\n", "Since UNION types are implemented on top of STRUCT types internally, they can be used with all the comparison operators as well as in both WHERE and HAVING clauses with the same semantics as STRUCTs. The \u201ctag\u201d is always stored as the first struct entry, which ensures that the UNION types are compared and ordered by \u201ctag\u201d first.", "\nFunctions\n", "See Union Functions.", "\n\nAbout this page\n\nReport content issue\nEdit this page on GitHub\n\n\n"], "Examples": ["CREATE TABLE tbl1 (u UNION(num INTEGER, str VARCHAR));\nINSERT INTO tbl1 values (1), ('two'), (union_value(str := 'three'));\n", "SELECT u FROM tbl1;\n", "SELECT union_extract(u, 'str') AS str\nFROM tbl1;\n", "SELECT u.str\nFROM tbl1;\n", "SELECT union_tag(u) AS t\nFROM tbl1;\n"], "Category": ["Nested or Composite Data Types"]}
{"index": 9, "HTML": ["https://duckdb.org/docs/sql/data_types/map"], "Title": ["Map"], "Feature": ["Map"], "Description": ["\n\n\nDocumentation\n/ SQL\n/ Data Types\n\n\n\n\n\nDark Mode\n\n\n1.1 (stable)\n\n\n\n1.1 (stable)\n\n1.0\n0.10\n0.9\n0.8\n0.7\n\n\n\n\nMap Type\n", "MAPs are similar to STRUCTs in that they are an ordered list of \u201centries\u201d where a key maps to a value. However, MAPs do not need to have the same keys present for each row, and thus are suitable for other use cases. MAPs are useful when the schema is unknown beforehand or when the schema varies per row; their flexibility is a key differentiator.", "MAPs must have a single type for all keys, and a single type for all values. Keys and values can be any type, and the type of the keys does not need to match the type of the values (Ex: a MAP of VARCHAR to INT is valid). MAPs may not have duplicate keys. MAPs return an empty list if a key is not found rather than throwing an error as structs do.", "In contrast, STRUCTs must have string keys, but each key may have a value of a different type. See the data types overview for a comparison between nested data types.", "To construct a MAP, use the bracket syntax preceded by the MAP keyword.", "\nCreating Maps\n", "A map with VARCHAR keys and INTEGER values. This returns {key1=10, key2=20, key3=30}:", "SELECT MAP {'key1': 10, 'key2': 20, 'key3': 30};\n", "Alternatively use the map_from_entries function. This returns {key1=10, key2=20, key3=30}:", "SELECT map_from_entries([('key1', 10), ('key2', 20), ('key3', 30)]);\n", "A map can be also created using two lists: keys and values. This returns {key1=10, key2=20, key3=30}:", "SELECT MAP(['key1', 'key2', 'key3'], [10, 20, 30]);\n", "A map can also use INTEGER keys and NUMERIC values. This returns {1=42.001, 5=-32.100}:", "SELECT MAP {1: 42.001, 5: -32.1};\n", "Keys and/or values can also be nested types. This returns {[a, b]=[1.1, 2.2], [c, d]=[3.3, 4.4]}:", "SELECT MAP {['a', 'b']: [1.1, 2.2], ['c', 'd']: [3.3, 4.4]};\n", "Create a table with a map column that has INTEGER keys and DOUBLE values:", "CREATE TABLE tbl (col MAP(INTEGER, DOUBLE));\n", "\nRetrieving from Maps\n", "MAPs use bracket notation for retrieving values. Selecting from a MAP returns a LIST rather than an individual value, with an empty LIST meaning that the key was not found.", "Use bracket notation to retrieve a list containing the value at a key's location. This returns [5]. Note that the expression in bracket notation must match the type of the map's key:", "SELECT MAP {'key1': 5, 'key2': 43}['key1'];\n", "To retrieve the underlying value, use list selection syntax to grab the first element. This returns 5:", "SELECT MAP {'key1': 5, 'key2': 43}['key1'][1];\n", "If the element is not in the map, an empty list will be returned. This returns []. Note that the expression in bracket notation must match the type of the map's key else an error is returned:", "SELECT MAP {'key1': 5, 'key2': 43}['key3'];\n", "The element_at function can also be used to retrieve a map value. This returns [5]:", "SELECT element_at(MAP {'key1': 5, 'key2': 43}, 'key1');\n", "\nComparison Operators\n", "Nested types can be compared using all the comparison operators.\nThese comparisons can be used in logical expressions\nfor both WHERE and HAVING clauses, as well as for creating Boolean values.", "The ordering is defined positionally in the same way that words can be ordered in a dictionary.\nNULL values compare greater than all other values and are considered equal to each other.", "At the top level, NULL nested values obey standard SQL NULL comparison rules:\ncomparing a NULL nested value to a non-NULL nested value produces a NULL result.\nComparing nested value members, however, uses the internal nested value rules for NULLs,\nand a NULL nested value member will compare above a non-NULL nested value member.", "\nFunctions\n", "See Map Functions.", "\n\nAbout this page\n\nReport content issue\nEdit this page on GitHub\n\n\n"], "Examples": ["SELECT MAP {'key1': 10, 'key2': 20, 'key3': 30};\n", "SELECT map_from_entries([('key1', 10), ('key2', 20), ('key3', 30)]);\n", "SELECT MAP(['key1', 'key2', 'key3'], [10, 20, 30]);\n", "SELECT MAP {1: 42.001, 5: -32.1};\n", "SELECT MAP {['a', 'b']: [1.1, 2.2], ['c', 'd']: [3.3, 4.4]};\n", "CREATE TABLE tbl (col MAP(INTEGER, DOUBLE));\n", "SELECT MAP {'key1': 5, 'key2': 43}['key1'];\n", "SELECT MAP {'key1': 5, 'key2': 43}['key1'][1];\n", "SELECT MAP {'key1': 5, 'key2': 43}['key3'];\n", "SELECT element_at(MAP {'key1': 5, 'key2': 43}, 'key1');\n"], "Category": ["Nested or Composite Data Types"]}
{"index": 34, "HTML": ["https://duckdb.org/docs/sql/data_types/struct"], "Title": ["Struct"], "Feature": ["Struct"], "Description": ["\n\n\nDocumentation\n/ SQL\n/ Data Types\n\n\n\n\n\nDark Mode\n\n\n1.1 (stable)\n\n\n\n1.1 (stable)\n\n1.0\n0.10\n0.9\n0.8\n0.7\n\n\n\n\nStruct Data Type\n", "Conceptually, a STRUCT column contains an ordered list of columns called \u201centries\u201d. The entries are referenced by name using strings. This document refers to those entry names as keys. Each row in the STRUCT column must have the same keys. The names of the struct entries are part of the schema. Each row in a STRUCT column must have the same layout. The names of the struct entries are case-insensitive.", "STRUCTs are typically used to nest multiple columns into a single column, and the nested column can be of any type, including other STRUCTs and LISTs.", "STRUCTs are similar to PostgreSQL's ROW type. The key difference is that DuckDB STRUCTs require the same keys in each row of a STRUCT column. This allows DuckDB to provide significantly improved performance by fully utilizing its vectorized execution engine, and also enforces type consistency for improved correctness. DuckDB includes a row function as a special way to produce a STRUCT, but does not have a ROW data type. See an example below and the STRUCT functions documentation for details.", "STRUCTs have a fixed schema. It is not possible to change the schema of a STRUCT using UPDATE operations.", "See the data types overview for a comparison between nested data types.", "\nCreating Structs\n", "Structs can be created using the struct_pack(name := expr, ...) function, the equivalent array notation {'name': expr, ...}, using a row variable, or using the row function.", "Create a struct using the struct_pack function. Note the lack of single quotes around the keys and the use of the := operator:", "SELECT struct_pack(key1 := 'value1', key2 := 42) AS s;\n", "Create a struct using the array notation:", "SELECT {'key1': 'value1', 'key2': 42} AS s;\n", "Create a struct using a row variable:", "SELECT d AS s FROM (SELECT 'value1' AS key1, 42 AS key2) d;\n", "Create a struct of integers:", "SELECT {'x': 1, 'y': 2, 'z': 3} AS s;\n", "Create a struct of strings with a NULL value:", "SELECT {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'} AS s;\n", "Create a struct with a different type for each key:", "SELECT {'key1': 'string', 'key2': 1, 'key3': 12.345} AS s;\n", "Create a struct of structs with NULL values:", "SELECT {\n        'birds': {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'},\n        'aliens': NULL,\n        'amphibians': {'yes': 'frog', 'maybe': 'salamander', 'huh': 'dragon', 'no': 'toad'}\n    } AS s;\n", "\nAdding Field(s)/Value(s) to Structs\n", "Add to a struct of integers:", "SELECT struct_insert({'a': 1, 'b': 2, 'c': 3}, d := 4) AS s;\n", "\nRetrieving from Structs\n", "Retrieving a value from a struct can be accomplished using dot notation, bracket notation, or through struct functions like struct_extract.", "Use dot notation to retrieve the value at a key's location. In the following query, the subquery generates a struct column a, which we then query with a.x.", "SELECT a.x FROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);\n", "If a key contains a space, simply wrap it in double quotes (\").", "SELECT a.\"x space\" FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);\n", "Bracket notation may also be used. Note that this uses single quotes (') since the goal is to specify a certain string key and only constant expressions may be used inside the brackets (no expressions):", "SELECT a['x space'] FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);\n", "The struct_extract function is also equivalent. This returns 1:", "SELECT struct_extract({'x space': 1, 'y': 2, 'z': 3}, 'x space');\n", "\nSTRUCT.*\n", "Rather than retrieving a single key from a struct, star notation (*) can be used to retrieve all keys from a struct as separate columns.\nThis is particularly useful when a prior operation creates a struct of unknown shape, or if a query must handle any potential struct keys.", "All keys within a struct can be returned as separate columns using *:", "SELECT a.*\nFROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);\n", "\n\n\nx\ny\nz\n\n\n\n\n1\n2\n3\n\n\n", "\nDot Notation Order of Operations\n", "Referring to structs with dot notation can be ambiguous with referring to schemas and tables. In general, DuckDB looks for columns first, then for struct keys within columns. DuckDB resolves references in these orders, using the first match to occur:", "\nNo Dots\n", "SELECT part1\nFROM tbl;\n", "\npart1 is a column\n", "\nOne Dot\n", "SELECT part1.part2\nFROM tbl;\n", "\npart1 is a table, part2 is a column\npart1 is a column, part2 is a property of that column\n", "\nTwo (or More) Dots\n", "SELECT part1.part2.part3\nFROM tbl;\n", "\npart1 is a schema, part2 is a table, part3 is a column\npart1 is a table, part2 is a column, part3 is a property of that column\npart1 is a column, part2 is a property of that column, part3 is a property of that column\n", "Any extra parts (e.g., .part4.part5, etc.) are always treated as properties", "\nCreating Structs with the row Function\n", "The row function can be used to automatically convert multiple columns to a single struct column.\nWhen using row the keys will be empty strings allowing for easy insertion into a table with a struct column.\nColumns, however, cannot be initialized with the row function, and must be explicitly named.\nFor example, inserting values into a struct column using the row function:", "CREATE TABLE t1 (s STRUCT(v VARCHAR, i INTEGER));\nINSERT INTO t1 VALUES (row('a', 42));\nSELECT * FROM t1;\n", "The table will contain a single entry:", "{'v': a, 'i': 42}\n", "The following produces the same result as above:", "CREATE TABLE t1 AS (\n    SELECT row('a', 42)::STRUCT(v VARCHAR, i INTEGER)\n);\n", "Initializing a struct column with the row function will fail:", "CREATE TABLE t2 AS SELECT row('a');\n", "Invalid Input Error: A table cannot be created from an unnamed struct\n", "When casting structs, the names of fields have to match. Therefore, the following query will fail:", "SELECT a::STRUCT(y INTEGER) AS b\nFROM\n    (SELECT {'x': 42} AS a);\n", "Mismatch Type Error: Type STRUCT(x INTEGER) does not match with STRUCT(y INTEGER). Cannot cast STRUCTs - element \"x\" in source struct was not found in target struct\n", "A workaround for this is to use struct_pack instead:", "SELECT struct_pack(y := a.x) AS b\nFROM\n    (SELECT {'x': 42} AS a);\n", "The row function can be used to return unnamed structs. For example:", "SELECT row(x, x + 1, y) FROM (SELECT 1 AS x, 'a' AS y) AS s;\n", "This produces (1, 2, a).", "If using multiple expressions when creating a struct, the row function is optional. The following query returns the same result as the previous one:", "SELECT (x, x + 1, y) AS s FROM (SELECT 1 AS x, 'a' AS y);\n", "\nComparison and Ordering\n", "The STRUCT type can be compared using all the comparison operators.\nThese comparisons can be used in logical expressions\nsuch as WHERE and HAVING clauses, and return BOOLEAN values.", "For comparisons, the keys of a STRUCT have a fixed positional order, from left to right. \nComparisons behave the same as row comparisons, therefore, matching keys must be at identical positions.", "Specifically, for any STRUCT comparison, the following rules apply:", "\nEquality. s1 and s2 are equal, if all respective values are equal.\nLess Than. For the first index i where s1.value[i] != s2.value[i]:\nIf s1.value[i] < s2.value[i], s1 is less than s2.\n", "NULL values are compared following PostgreSQL's semantics.\nLower nesting levels are used for tie-breaking.", "Here are some queries returning true for the comparison.", "SELECT {'k1': 2, 'k2': 3} < {'k1': 2, 'k2': 4} AS result;\n", "SELECT {'k1': 'hello'} < {'k1': 'world'} AS result;\n", "These queries return false.", "SELECT {'k2': 4, 'k1': 3} < {'k2': 2, 'k1': 4} AS result;\n", "SELECT {'k1': [4, 3]} < {'k1': [3, 6, 7]} AS result;\n", "These queries return NULL.", "SELECT {'k1': 2, 'k2': 3} < {'k1': 2, 'k2': NULL} AS result;\n", "This query returns a Binder Error because the keys do not match positionally.", "SELECT {'k1': 2, 'k2': 3} < {'k2': 2, 'k1': 4} AS result;\n", "Binder Error: Cannot compare values of type STRUCT(k1 INTEGER, k2 INTEGER)\nand type STRUCT(k2 INTEGER, k1 INTEGER) - an explicit cast is required\n", "\nFunctions\n", "See Struct Functions.", "\n\nAbout this page\n\nReport content issue\nEdit this page on GitHub\n\n\n"], "Examples": ["SELECT struct_pack(key1 := 'value1', key2 := 42) AS s;\n", "SELECT {'key1': 'value1', 'key2': 42} AS s;\n", "SELECT d AS s FROM (SELECT 'value1' AS key1, 42 AS key2) d;\n", "SELECT {'x': 1, 'y': 2, 'z': 3} AS s;\n", "SELECT {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'} AS s;\n", "SELECT {'key1': 'string', 'key2': 1, 'key3': 12.345} AS s;\n", "SELECT {\n        'birds': {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'},\n        'aliens': NULL,\n        'amphibians': {'yes': 'frog', 'maybe': 'salamander', 'huh': 'dragon', 'no': 'toad'}\n    } AS s;\n", "SELECT struct_insert({'a': 1, 'b': 2, 'c': 3}, d := 4) AS s;\n", "SELECT a.x FROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);\n", "SELECT a.\"x space\" FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);\n", "SELECT a['x space'] FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);\n", "SELECT struct_extract({'x space': 1, 'y': 2, 'z': 3}, 'x space');\n", "SELECT a.*\nFROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);\n", "SELECT part1\nFROM tbl;\n", "SELECT part1.part2\nFROM tbl;\n", "SELECT part1.part2.part3\nFROM tbl;\n", "CREATE TABLE t1 (s STRUCT(v VARCHAR, i INTEGER));\nINSERT INTO t1 VALUES (row('a', 42));\nSELECT * FROM t1;\n", "{'v': a, 'i': 42}\n", "CREATE TABLE t1 AS (\n    SELECT row('a', 42)::STRUCT(v VARCHAR, i INTEGER)\n);\n", "CREATE TABLE t2 AS SELECT row('a');\n", "Invalid Input Error: A table cannot be created from an unnamed struct\n", "SELECT a::STRUCT(y INTEGER) AS b\nFROM\n    (SELECT {'x': 42} AS a);\n", "Mismatch Type Error: Type STRUCT(x INTEGER) does not match with STRUCT(y INTEGER). Cannot cast STRUCTs - element \"x\" in source struct was not found in target struct\n", "SELECT struct_pack(y := a.x) AS b\nFROM\n    (SELECT {'x': 42} AS a);\n", "SELECT row(x, x + 1, y) FROM (SELECT 1 AS x, 'a' AS y) AS s;\n", "SELECT (x, x + 1, y) AS s FROM (SELECT 1 AS x, 'a' AS y);\n", "SELECT {'k1': 2, 'k2': 3} < {'k1': 2, 'k2': 4} AS result;\n", "SELECT {'k1': 'hello'} < {'k1': 'world'} AS result;\n", "SELECT {'k2': 4, 'k1': 3} < {'k2': 2, 'k1': 4} AS result;\n", "SELECT {'k1': [4, 3]} < {'k1': [3, 6, 7]} AS result;\n", "SELECT {'k1': 2, 'k2': 3} < {'k1': 2, 'k2': NULL} AS result;\n", "SELECT {'k1': 2, 'k2': 3} < {'k2': 2, 'k1': 4} AS result;\n", "Binder Error: Cannot compare values of type STRUCT(k1 INTEGER, k2 INTEGER)\nand type STRUCT(k2 INTEGER, k1 INTEGER) - an explicit cast is required\n"], "Category": ["Nested or Composite Data Types"]}
