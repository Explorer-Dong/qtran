{"index": 5, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/date"], "Title": ["Date"], "Feature": ["Date"], "Description": ["Date", "A date. Stored in two bytes as the number of days since 1970-01-01 (unsigned). Allows storing values from just after the beginning of the Unix Epoch to the upper threshold defined by a constant at the compilation stage (currently, this is until the year 2149, but the final fully-supported year is 2148).", "Supported range of values: [1970-01-01, 2149-06-06].", "The date value is stored without the time zone.", "Example", "Creating a table with a Date-type column and inserting data into it:", "CREATE TABLE dt(    `timestamp` Date,    `event_id` UInt8)ENGINE = TinyLog;", "-- Parse Date-- - from string,-- - from 'small' integer interpreted as number of days since 1970-01-01, and-- - from 'big' integer interpreted as number of seconds since 1970-01-01.INSERT INTO dt VALUES ('2019-01-01', 1), (17897, 2), (1546300800, 3);SELECT * FROM dt;", "\u250c\u2500\u2500timestamp\u2500\u252c\u2500event_id\u2500\u2510\u2502 2019-01-01 \u2502        1 \u2502\u2502 2019-01-01 \u2502        2 \u2502\u2502 2019-01-01 \u2502        3 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "See Also", "Functions for working with dates and timesOperators for working with dates and timesDateTime data type"], "Examples": ["CREATE TABLE dt(    `timestamp` Date,    `event_id` UInt8)ENGINE = TinyLog;", "-- Parse Date-- - from string,-- - from 'small' integer interpreted as number of days since 1970-01-01, and-- - from 'big' integer interpreted as number of seconds since 1970-01-01.INSERT INTO dt VALUES ('2019-01-01', 1), (17897, 2), (1546300800, 3);SELECT * FROM dt;"], "Category": ["Date and Time Data Types"]}
{"index": 6, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/date32"], "Title": ["Date32"], "Feature": ["Date32"], "Description": ["Date32", "A date. Supports the date range same with DateTime64. Stored as a signed 32-bit integer in native byte order with the value representing the days since 1970-01-01 (0 represents 1970-01-01 and negative values represent the days before 1970).", "Examples", "Creating a table with a Date32-type column and inserting data into it:", "CREATE TABLE dt32(    `timestamp` Date32,    `event_id` UInt8)ENGINE = TinyLog;", "-- Parse Date-- - from string,-- - from 'small' integer interpreted as number of days since 1970-01-01, and-- - from 'big' integer interpreted as number of seconds since 1970-01-01.INSERT INTO dt32 VALUES ('2100-01-01', 1), (47482, 2), (4102444800, 3);SELECT * FROM dt32;", "\u250c\u2500\u2500timestamp\u2500\u252c\u2500event_id\u2500\u2510\u2502 2100-01-01 \u2502        1 \u2502\u2502 2100-01-01 \u2502        2 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "See Also", "toDate32toDate32OrZerotoDate32OrNull"], "Examples": ["CREATE TABLE dt32(    `timestamp` Date32,    `event_id` UInt8)ENGINE = TinyLog;", "-- Parse Date-- - from string,-- - from 'small' integer interpreted as number of days since 1970-01-01, and-- - from 'big' integer interpreted as number of seconds since 1970-01-01.INSERT INTO dt32 VALUES ('2100-01-01', 1), (47482, 2), (4102444800, 3);SELECT * FROM dt32;"], "Category": ["Date and Time Data Types"]}
{"index": 7, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/datetime"], "Title": ["DateTime"], "Feature": ["DateTime"], "Description": ["DateTime", "Allows to store an instant in time, that can be expressed as a calendar date and a time of a day.", "Syntax:", "DateTime([timezone])", "Supported range of values: [1970-01-01 00:00:00, 2106-02-07 06:28:15].", "Resolution: 1 second.", "Speed\u200b", "The Date datatype is faster than DateTime under most conditions.", "The Date type requires 2 bytes of storage, while DateTime requires 4. However, when the database compresses the database, this difference is amplified. This amplification is due to the minutes and seconds in DateTime being less compressible. Filtering and aggregating Date instead of DateTime is also faster.", "Usage Remarks\u200b", "The point in time is saved as a Unix timestamp, regardless of the time zone or daylight saving time. The time zone affects how the values of the DateTime type values are displayed in text format and how the values specified as strings are parsed (\u20182020-01-01 05:00:01\u2019).", "Timezone agnostic Unix timestamp is stored in tables, and the timezone is used to transform it to text format or back during data import/export or to make calendar calculations on the values (example: toDate, toHour functions etc.). The time zone is not stored in the rows of the table (or in resultset), but is stored in the column metadata.", "A list of supported time zones can be found in the IANA Time Zone Database and also can be queried by SELECT * FROM system.time_zones. The list is also available at Wikipedia.", "You can explicitly set a time zone for DateTime-type columns when creating a table. Example: DateTime('UTC'). If the time zone isn\u2019t set, ClickHouse uses the value of the timezone parameter in the server settings or the operating system settings at the moment of the ClickHouse server start.", "The clickhouse-client applies the server time zone by default if a time zone isn\u2019t explicitly set when initializing the data type. To use the client time zone, run clickhouse-client with the --use_client_time_zone parameter.", "ClickHouse outputs values depending on the value of the date_time_output_format setting. YYYY-MM-DD hh:mm:ss text format by default. Additionally, you can change the output with the formatDateTime function.", "When inserting data into ClickHouse, you can use different formats of date and time strings, depending on the value of the date_time_input_format setting.", "Examples\u200b", "1. Creating a table with a DateTime-type column and inserting data into it:", "CREATE TABLE dt(    `timestamp` DateTime('Asia/Istanbul'),    `event_id` UInt8)ENGINE = TinyLog;", "-- Parse DateTime-- - from string,-- - from integer interpreted as number of seconds since 1970-01-01.INSERT INTO dt VALUES ('2019-01-01 00:00:00', 1), (1546300800, 3);SELECT * FROM dt;", "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500timestamp\u2500\u252c\u2500event_id\u2500\u2510\u2502 2019-01-01 00:00:00 \u2502        2 \u2502\u2502 2019-01-01 03:00:00 \u2502        1 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "When inserting datetime as an integer, it is treated as Unix Timestamp (UTC). 1546300800 represents '2019-01-01 00:00:00' UTC. However, as timestamp column has Asia/Istanbul (UTC+3) timezone specified, when outputting as string the value will be shown as '2019-01-01 03:00:00'When inserting string value as datetime, it is treated as being in column timezone. '2019-01-01 00:00:00' will be treated as being in Asia/Istanbul timezone and saved as 1546290000.", "2. Filtering on DateTime values", "SELECT * FROM dt WHERE timestamp = toDateTime('2019-01-01 00:00:00', 'Asia/Istanbul')", "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500timestamp\u2500\u252c\u2500event_id\u2500\u2510\u2502 2019-01-01 00:00:00 \u2502        1 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "DateTime column values can be filtered using a string value in WHERE predicate. It will be converted to DateTime automatically:", "SELECT * FROM dt WHERE timestamp = '2019-01-01 00:00:00'", "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500timestamp\u2500\u252c\u2500event_id\u2500\u2510\u2502 2019-01-01 00:00:00 \u2502        1 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "3. Getting a time zone for a DateTime-type column:", "SELECT toDateTime(now(), 'Asia/Istanbul') AS column, toTypeName(column) AS x", "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500column\u2500\u252c\u2500x\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 2019-10-16 04:12:04 \u2502 DateTime('Asia/Istanbul') \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "4. Timezone conversion", "SELECTtoDateTime(timestamp, 'Europe/London') as lon_time,toDateTime(timestamp, 'Asia/Istanbul') as mos_timeFROM dt", "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500lon_time\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500mos_time\u2500\u2510\u2502 2019-01-01 00:00:00 \u2502 2019-01-01 03:00:00 \u2502\u2502 2018-12-31 21:00:00 \u2502 2019-01-01 00:00:00 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "As timezone conversion only changes the metadata, the operation has no computation cost.", "Limitations on time zones support\u200b", "Some time zones may not be supported completely. There are a few cases:", "If the offset from UTC is not a multiple of 15 minutes, the calculation of hours and minutes can be incorrect. For example, the time zone in Monrovia, Liberia has offset UTC -0:44:30 before 7 Jan 1972. If you are doing calculations on the historical time in Monrovia timezone, the time processing functions may give incorrect results. The results after 7 Jan 1972 will be correct nevertheless.", "If the time transition (due to daylight saving time or for other reasons) was performed at a point of time that is not a multiple of 15 minutes, you can also get incorrect results at this specific day.", "Non-monotonic calendar dates. For example, in Happy Valley - Goose Bay, the time was transitioned one hour backwards at 00:01:00 7 Nov 2010 (one minute after midnight). So after 6th Nov has ended, people observed a whole one minute of 7th Nov, then time was changed back to 23:01 6th Nov and after another 59 minutes the 7th Nov started again. ClickHouse does not (yet) support this kind of fun. During these days the results of time processing functions may be slightly incorrect.", "Similar issue exists for Casey Antarctic station in year 2010. They changed time three hours back at 5 Mar, 02:00. If you are working in antarctic station, please don't be afraid to use ClickHouse. Just make sure you set timezone to UTC or be aware of inaccuracies.", "Time shifts for multiple days. Some pacific islands changed their timezone offset from UTC+14 to UTC-12. That's alright but some inaccuracies may present if you do calculations with their timezone for historical time points at the days of conversion.", "See Also\u200b", "Type conversion functionsFunctions for working with dates and timesFunctions for working with arraysThe date_time_input_format settingThe date_time_output_format settingThe timezone server configuration parameterThe session_timezone settingOperators for working with dates and timesThe Date data type"], "Examples": ["DateTime([timezone])", "CREATE TABLE dt(    `timestamp` DateTime('Asia/Istanbul'),    `event_id` UInt8)ENGINE = TinyLog;", "-- Parse DateTime-- - from string,-- - from integer interpreted as number of seconds since 1970-01-01.INSERT INTO dt VALUES ('2019-01-01 00:00:00', 1), (1546300800, 3);SELECT * FROM dt;", "SELECT * FROM dt WHERE timestamp = toDateTime('2019-01-01 00:00:00', 'Asia/Istanbul')", "SELECT * FROM dt WHERE timestamp = '2019-01-01 00:00:00'", "SELECT toDateTime(now(), 'Asia/Istanbul') AS column, toTypeName(column) AS x", "SELECTtoDateTime(timestamp, 'Europe/London') as lon_time,toDateTime(timestamp, 'Asia/Istanbul') as mos_timeFROM dt"], "Category": ["Date and Time Data Types"]}
{"index": 8, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/datetime64"], "Title": ["DateTime64"], "Feature": ["DateTime64"], "Description": ["DateTime64", "Allows to store an instant in time, that can be expressed as a calendar date and a time of a day, with defined sub-second precision", "Tick size (precision): 10-precision seconds. Valid range: [ 0 : 9 ].\nTypically, are used - 3 (milliseconds), 6 (microseconds), 9 (nanoseconds).", "Syntax:", "DateTime64(precision, [timezone])", "Internally, stores data as a number of \u2018ticks\u2019 since epoch start (1970-01-01 00:00:00 UTC) as Int64. The tick resolution is determined by the precision parameter. Additionally, the DateTime64 type can store time zone that is the same for the entire column, that affects how the values of the DateTime64 type values are displayed in text format and how the values specified as strings are parsed (\u20182020-01-01 05:00:01.000\u2019). The time zone is not stored in the rows of the table (or in resultset), but is stored in the column metadata. See details in DateTime.", "Supported range of values: [1900-01-01 00:00:00, 2299-12-31 23:59:59.99999999]", "Note: The precision of the maximum value is 8. If the maximum precision of 9 digits (nanoseconds) is used, the maximum supported value is 2262-04-11 23:47:16 in UTC.", "Examples\u200b", "Creating a table with DateTime64-type column and inserting data into it:", "CREATE TABLE dt64(    `timestamp` DateTime64(3, 'Asia/Istanbul'),    `event_id` UInt8)ENGINE = TinyLog;", "-- Parse DateTime-- - from integer interpreted as number of seconds since 1970-01-01.-- - from string,INSERT INTO dt64 VALUES (1546300800123, 1), (1546300800.123, 2), ('2019-01-01 00:00:00', 3);SELECT * FROM dt64;", "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500timestamp\u2500\u252c\u2500event_id\u2500\u2510\u2502 2019-01-01 03:00:00.123 \u2502        1 \u2502\u2502 2019-01-01 03:00:00.123 \u2502        2 \u2502\u2502 2019-01-01 00:00:00.000 \u2502        3 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "When inserting datetime as an integer, it is treated as an appropriately scaled Unix Timestamp (UTC). 1546300800000 (with precision 3) represents '2019-01-01 00:00:00' UTC. However, as timestamp column has Asia/Istanbul (UTC+3) timezone specified, when outputting as a string the value will be shown as '2019-01-01 03:00:00'. Inserting datetime as a decimal will treat it similarly as an integer, except the value before the decimal point is the Unix Timestamp up to and including the seconds, and after the decimal point will be treated as the precision.When inserting string value as datetime, it is treated as being in column timezone. '2019-01-01 00:00:00' will be treated as being in Asia/Istanbul timezone and stored as 1546290000000.", "Filtering on DateTime64 values", "SELECT * FROM dt64 WHERE timestamp = toDateTime64('2019-01-01 00:00:00', 3, 'Asia/Istanbul');", "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500timestamp\u2500\u252c\u2500event_id\u2500\u2510\u2502 2019-01-01 00:00:00.000 \u2502        3 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Unlike DateTime, DateTime64 values are not converted from String automatically.", "SELECT * FROM dt64 WHERE timestamp = toDateTime64(1546300800.123, 3);", "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500timestamp\u2500\u252c\u2500event_id\u2500\u2510\u2502 2019-01-01 03:00:00.123 \u2502        1 \u2502\u2502 2019-01-01 03:00:00.123 \u2502        2 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Contrary to inserting, the toDateTime64 function will treat all values as the decimal variant, so precision needs to\nbe given after the decimal point.", "Getting a time zone for a DateTime64-type value:", "SELECT toDateTime64(now(), 3, 'Asia/Istanbul') AS column, toTypeName(column) AS x;", "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500column\u2500\u252c\u2500x\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 2023-06-05 00:09:52.000 \u2502 DateTime64(3, 'Asia/Istanbul') \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Timezone conversion", "SELECTtoDateTime64(timestamp, 3, 'Europe/London') as lon_time,toDateTime64(timestamp, 3, 'Asia/Istanbul') as istanbul_timeFROM dt64;", "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500lon_time\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500istanbul_time\u2500\u2510\u2502 2019-01-01 00:00:00.123 \u2502 2019-01-01 03:00:00.123 \u2502\u2502 2019-01-01 00:00:00.123 \u2502 2019-01-01 03:00:00.123 \u2502\u2502 2018-12-31 21:00:00.000 \u2502 2019-01-01 00:00:00.000 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "See Also", "Type conversion functionsFunctions for working with dates and timesThe date_time_input_format settingThe date_time_output_format settingThe timezone server configuration parameterThe session_timezone settingOperators for working with dates and timesDate data typeDateTime data type"], "Examples": ["DateTime64(precision, [timezone])", "CREATE TABLE dt64(    `timestamp` DateTime64(3, 'Asia/Istanbul'),    `event_id` UInt8)ENGINE = TinyLog;", "-- Parse DateTime-- - from integer interpreted as number of seconds since 1970-01-01.-- - from string,INSERT INTO dt64 VALUES (1546300800123, 1), (1546300800.123, 2), ('2019-01-01 00:00:00', 3);SELECT * FROM dt64;", "SELECT * FROM dt64 WHERE timestamp = toDateTime64('2019-01-01 00:00:00', 3, 'Asia/Istanbul');", "SELECT * FROM dt64 WHERE timestamp = toDateTime64(1546300800.123, 3);", "SELECT toDateTime64(now(), 3, 'Asia/Istanbul') AS column, toTypeName(column) AS x;", "SELECTtoDateTime64(timestamp, 3, 'Europe/London') as lon_time,toDateTime64(timestamp, 3, 'Asia/Istanbul') as istanbul_timeFROM dt64;"], "Category": ["Date and Time Data Types"]}
{"index": 28, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/time"], "Title": ["Time"], "Feature": ["Time"], "Description": ["Time", "Data type Time represents a time with hour, minute, and second components. It is independent of any calendar date and is suitable for values which do not need day, months and year components.", "Syntax:", "Time", "Text representation range: [-999:59:59, 999:59:59].\n\nResolution: 1 second.", "Implementation details\u200b", "Representation and Performance. Data type Time internally stores a signed 32-bit integer that encodes the seconds. Values of type Time and DateTime have the same byte size and thus comparable performance.", "Normalization. When parsing strings to Time, the time components are normalized and not validated. For example, 25:70:70 is interpreted as 26:11:10.", "Negative values. Leading minus signs are supported and preserved. Negative values typically arise from arithmetic operations on Time values. For Time type, negative inputs are preserved for both text (e.g., '-01:02:03') and numeric inputs (e.g., -3723).", "Saturation. The time-of-day component is capped to the range [-999:59:59, 999:59:59]. Values with hours beyond 999 (or below -999) are represented and round-tripped via text as 999:59:59 (or -999:59:59).", "Time zones. Time does not support time zones, i.e. Time value are interpreted without regional context. Specifying a time zone for Time as a type parameter or during value creation throws an error. Likewise, attempts to apply or change the time zone on Time columns are not supported and result in an error. Time values are not silently reinterpreted under different time zones."], "Examples": ["CREATE TABLE tab\n(\n    `event_id` UInt8,\n    `time` Time\n)\nENGINE = TinyLog;", "-- Parse Time\n-- - from string,\n-- - from integer interpreted as number of seconds since 00:00:00.\nINSERT INTO tab VALUES (1, '14:30:25'), (2, 52225);\n\nSELECT * FROM tab ORDER BY event_id;", "SELECT * FROM tab WHERE time = toTime('14:30:25')", "SELECT * FROM tab WHERE time = '14:30:25'", "SELECT CAST('14:30:25' AS Time) AS column, toTypeName(column) AS type"], "Category": ["Date and Time Data Types"]}
{"index": 29, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/time64"], "Title": ["Time64"], "Feature": ["Time64(precision)"], "Description": ["Time64", "Data type Time64 represents a time-of-day with fractional seconds. It has no calendar date components (day, month, year). The precision parameter defines the number of fractional digits and therefore the tick size.", "Tick size (precision): 10-precision seconds. Valid range: 0..9. Common choices are 3 (milliseconds), 6 (microseconds), and 9 (nanoseconds).", "Syntax:", "Time64(precision)", "Internally, Time64 stores a signed 64-bit decimal (Decimal64) number of fractional seconds. The tick resolution is determined by the precision parameter. Time zones are not supported: specifying a time zone with Time64 will throw an error.", "Unlike DateTime64, Time64 does not store a date component. See also Time.", "Text representation range: [-999:59:59.000, 999:59:59.999] for precision = 3. In general, the minimum is -999:59:59 and the maximum is 999:59:59 with up to precision fractional digits (for precision = 9, the minimum is -999:59:59.999999999).", "Implementation details\u200b", "Representation. Signed Decimal64 value counting fractional second with precision fractional digits.\n\n", "Normalization. When parsing strings to Time64, the time components are normalized and not validated. For example, 25:70:70 is interpreted as 26:11:10.", "Negative values. Leading minus signs are supported and preserved. Negative values typically arise from arithmetic operations on Time64 values. For Time64, negative inputs are preserved for both text (e.g., '-01:02:03.123') and numeric inputs (e.g., -3723.123).", "Saturation. The time-of-day component is capped to the range [-999:59:59.xxx, 999:59:59.xxx] when converting to components or serialising to text. The stored numeric value may exceed this range; however, any component extraction (hours, minutes, seconds) and textual representation use the saturated value.", "Time zones. Time64 does not support time zones. Specifying a time zone when creating a Time64 type or value throws an error. Likewise, attempts to apply or change the time zone on Time64 columns is not supported and results in an error."], "Examples": ["CREATE TABLE tab64\n(\n    `event_id` UInt8,\n    `time` Time64(3)\n)\nENGINE = TinyLog;", "-- Parse Time64\n-- - from string,\n-- - from a number of seconds since 00:00:00 (fractional part according to precision).\nINSERT INTO tab64 VALUES (1, '14:30:25'), (2, 52225.123), (3, '14:30:25');\n\nSELECT * FROM tab64 ORDER BY event_id;", "SELECT * FROM tab64 WHERE time = toTime64('14:30:25', 3);", "SELECT * FROM tab64 WHERE time = toTime64(52225.123, 3);", "SELECT CAST('14:30:25.250' AS Time64(3)) AS column, toTypeName(column) AS type;"], "Category": ["Date and Time Data Types"]}
