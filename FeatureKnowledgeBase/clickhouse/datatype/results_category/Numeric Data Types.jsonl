{"index": 0, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/int-uint"], "Title": ["UInt8, UInt16, UInt32, UInt64, UInt128, UInt256, Int8, Int16, Int32, Int64, Int128, Int256"], "Feature": ["UInt8, UInt16, UInt32, UInt64, UInt128, UInt256, Int8, Int16, Int32, Int64, Int128, Int256"], "Description": ["UInt8, UInt16, UInt32, UInt64, UInt128, UInt256, Int8, Int16, Int32, Int64, Int128, Int256", "Fixed-length integers, with or without a sign.", "When creating tables, numeric parameters for integer numbers can be set (e.g. TINYINT(8), SMALLINT(16), INT(32), BIGINT(64)), but ClickHouse ignores them.", "Int Ranges\u200b", "Int8 \u2014 [-128 : 127]Int16 \u2014 [-32768 : 32767]Int32 \u2014 [-2147483648 : 2147483647]Int64 \u2014 [-9223372036854775808 : 9223372036854775807]Int128 \u2014 [-170141183460469231731687303715884105728 : 170141183460469231731687303715884105727]Int256 \u2014 [-57896044618658097711785492504343953926634992332820282019728792003956564819968 : 57896044618658097711785492504343953926634992332820282019728792003956564819967]", "Aliases:", "Int8 \u2014 TINYINT, INT1, BYTE, TINYINT SIGNED, INT1 SIGNED.Int16 \u2014 SMALLINT, SMALLINT SIGNED.Int32 \u2014 INT, INTEGER, MEDIUMINT, MEDIUMINT SIGNED, INT SIGNED, INTEGER SIGNED.Int64 \u2014 BIGINT, SIGNED, BIGINT SIGNED, TIME.", "UInt Ranges\u200b", "UInt8 \u2014 [0 : 255]UInt16 \u2014 [0 : 65535]UInt32 \u2014 [0 : 4294967295]UInt64 \u2014 [0 : 18446744073709551615]UInt128 \u2014 [0 : 340282366920938463463374607431768211455]UInt256 \u2014 [0 : 115792089237316195423570985008687907853269984665640564039457584007913129639935]", "Aliases:", "UInt8 \u2014 TINYINT UNSIGNED, INT1 UNSIGNED.UInt16 \u2014 SMALLINT UNSIGNED.UInt32 \u2014 MEDIUMINT UNSIGNED, INT UNSIGNED, INTEGER UNSIGNEDUInt64 \u2014 UNSIGNED, BIGINT UNSIGNED, BIT, SET"], "Examples": [], "Category": ["Numeric Data Types"]}
{"index": 1, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/float"], "Title": ["Float32, Float64, BFloat16"], "Feature": ["Float32, Float64, BFloat16"], "Description": ["Float32, Float64", "NoteIf you need accurate calculations, in particular if you work with financial or business data requiring a high precision, you should consider using Decimal instead. Floating Point Numbers might lead to inaccurate results as illustrated below:CREATE TABLE IF NOT EXISTS float_vs_decimal(   my_float Float64,   my_decimal Decimal64(3))Engine=MergeTreeORDER BY tuple();# Generate 1 000 000 random numbers with 2 decimal places and store them as a float and as a decimalINSERT INTO float_vs_decimal SELECT round(randCanonical(), 3) AS res, res FROM system.numbers LIMIT 1000000;SELECT sum(my_float), sum(my_decimal) FROM float_vs_decimal;\u250c\u2500\u2500\u2500\u2500\u2500\u2500sum(my_float)\u2500\u252c\u2500sum(my_decimal)\u2500\u2510\u2502 499693.60500000004 \u2502      499693.605 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518SELECT sumKahan(my_float), sumKahan(my_decimal) FROM float_vs_decimal;\u250c\u2500sumKahan(my_float)\u2500\u252c\u2500sumKahan(my_decimal)\u2500\u2510\u2502         499693.605 \u2502           499693.605 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "The equivalent types in ClickHouse and in C are given below:", "Float32 \u2014 float.Float64 \u2014 double.", "Float types in ClickHouse have the following aliases:", "Float32 \u2014 FLOAT, REAL, SINGLE.Float64 \u2014 DOUBLE, DOUBLE PRECISION.", "When creating tables, numeric parameters for floating point numbers can be set (e.g. FLOAT(12), FLOAT(15, 22), DOUBLE(12), DOUBLE(4, 18)), but ClickHouse ignores them.", "Using Floating-point Numbers\u200b", "Computations with floating-point numbers might produce a rounding error.", "SELECT 1 - 0.9", "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500minus(1, 0.9)\u2500\u2510\u2502 0.09999999999999998 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "The result of the calculation depends on the calculation method (the processor type and architecture of the computer system).Floating-point calculations might result in numbers such as infinity (Inf) and \u201cnot-a-number\u201d (NaN). This should be taken into account when processing the results of calculations.When parsing floating-point numbers from text, the result might not be the nearest machine-representable number.", "NaN and Inf\u200b", "In contrast to standard SQL, ClickHouse supports the following categories of floating-point numbers:", "Inf \u2013 Infinity.", "SELECT 0.5 / 0", "\u250c\u2500divide(0.5, 0)\u2500\u2510\u2502            inf \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "-Inf \u2014 Negative infinity.", "SELECT -0.5 / 0", "\u250c\u2500divide(-0.5, 0)\u2500\u2510\u2502            -inf \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "NaN \u2014 Not a number.", "SELECT 0 / 0", "\u250c\u2500divide(0, 0)\u2500\u2510\u2502          nan \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "See the rules for NaN sorting in the section ORDER BY clause.", "BFloat16\nBFloat16 is a 16-bit floating point data type with 8-bit exponent, sign, and 7-bit mantissa. It is useful for machine learning and AI applications.\n\nClickHouse supports conversions between Float32 and BFloat16 which can be done using the toFloat32() or toBFloat16 functions."], "Examples": ["CREATE TABLE IF NOT EXISTS float_vs_decimal(   my_float Float64,   my_decimal Decimal64(3))Engine=MergeTreeORDER BY tuple();# Generate 1 000 000 random numbers with 2 decimal places and store them as a float and as a decimalINSERT INTO float_vs_decimal SELECT round(randCanonical(), 3) AS res, res FROM system.numbers LIMIT 1000000;", "SELECT 1 - 0.9", "SELECT 0.5 / 0", "SELECT -0.5 / 0", "SELECT 0 / 0"], "Category": ["Numeric Data Types"]}
{"index": 2, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/decimal"], "Title": ["Decimal, Decimal(P), Decimal(P, S), Decimal32(S), Decimal64(S), Decimal128(S), Decimal256(S)"], "Feature": ["Decimal, Decimal(P), Decimal(P, S), Decimal32(S), Decimal64(S), Decimal128(S), Decimal256(S)"], "Description": ["Decimal, Decimal(P), Decimal(P, S), Decimal32(S), Decimal64(S), Decimal128(S), Decimal256(S)", "Signed fixed-point numbers that keep precision during add, subtract and multiply operations. For division least significant digits are discarded (not rounded).", "Parameters\u200b", "P - precision. Valid range: [ 1 : 76 ]. Determines how many decimal digits number can have (including fraction). By default, the precision is 10.S - scale. Valid range: [ 0 : P ]. Determines how many decimal digits fraction can have.", "Decimal(P) is equivalent to Decimal(P, 0). Similarly, the syntax Decimal is equivalent to Decimal(10, 0).", "Depending on P parameter value Decimal(P, S) is a synonym for:", "P from [ 1 : 9 ] - for Decimal32(S)P from [ 10 : 18 ] - for Decimal64(S)P from [ 19 : 38 ] - for Decimal128(S)P from [ 39 : 76 ] - for Decimal256(S)", "Decimal Value Ranges\u200b", "Decimal32(S) - ( -1 * 10^(9 - S), 1 * 10^(9 - S) )Decimal64(S) - ( -1 * 10^(18 - S), 1 * 10^(18 - S) )Decimal128(S) - ( -1 * 10^(38 - S), 1 * 10^(38 - S) )Decimal256(S) - ( -1 * 10^(76 - S), 1 * 10^(76 - S) )", "For example, Decimal32(4) can contain numbers from -99999.9999 to 99999.9999 with 0.0001 step.", "Internal Representation\u200b", "Internally data is represented as normal signed integers with respective bit width. Real value ranges that can be stored in memory are a bit larger than specified above, which are checked only on conversion from a string.", "Because modern CPUs do not support 128-bit and 256-bit integers natively, operations on Decimal128 and Decimal256 are emulated. Thus, Decimal128 and Decimal256 work significantly slower than Decimal32/Decimal64.", "Operations and Result Type\u200b", "Binary operations on Decimal result in wider result type (with any order of arguments).", "Decimal64(S1) <op> Decimal32(S2) -> Decimal64(S)Decimal128(S1) <op> Decimal32(S2) -> Decimal128(S)Decimal128(S1) <op> Decimal64(S2) -> Decimal128(S)Decimal256(S1) <op> Decimal<32|64|128>(S2) -> Decimal256(S)", "Rules for scale:", "add, subtract: S = max(S1, S2).multiply: S = S1 + S2.divide: S = S1.", "For similar operations between Decimal and integers, the result is Decimal of the same size as an argument.", "Operations between Decimal and Float32/Float64 are not defined. If you need them, you can explicitly cast one of argument using toDecimal32, toDecimal64, toDecimal128 or toFloat32, toFloat64 builtins. Keep in mind that the result will lose precision and type conversion is a computationally expensive operation.", "Some functions on Decimal return result as Float64 (for example, var or stddev). Intermediate calculations might still be performed in Decimal, which might lead to different results between Float64 and Decimal inputs with the same values.", "Overflow Checks\u200b", "During calculations on Decimal, integer overflows might happen. Excessive digits in a fraction are discarded (not rounded). Excessive digits in integer part will lead to an exception.", "DangerOverflow check is not implemented for Decimal128 and Decimal256. In case of overflow incorrect result is returned, no exception is thrown.", "SELECT toDecimal32(2, 4) AS x, x / 3", "\u250c\u2500\u2500\u2500\u2500\u2500\u2500x\u2500\u252c\u2500divide(toDecimal32(2, 4), 3)\u2500\u2510\u2502 2.0000 \u2502                       0.6666 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "SELECT toDecimal32(4.2, 8) AS x, x * x", "DB::Exception: Scale is out of bounds.", "SELECT toDecimal32(4.2, 8) AS x, 6 * x", "DB::Exception: Decimal math overflow.", "Overflow checks lead to operations slowdown. If it is known that overflows are not possible, it makes sense to disable checks using decimal_check_overflow setting. When checks are disabled and overflow happens, the result will be incorrect:", "SET decimal_check_overflow = 0;SELECT toDecimal32(4.2, 8) AS x, 6 * x", "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500x\u2500\u252c\u2500multiply(6, toDecimal32(4.2, 8))\u2500\u2510\u2502 4.20000000 \u2502                     -17.74967296 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Overflow checks happen not only on arithmetic operations but also on value comparison:", "SELECT toDecimal32(1, 8) < 100", "DB::Exception: Can't compare.", "See also", "isDecimalOverflowcountDigits"], "Examples": ["SELECT toDecimal32(2, 4) AS x, x / 3", "SELECT toDecimal32(4.2, 8) AS x, x * x", "SELECT toDecimal32(4.2, 8) AS x, 6 * x", "SET decimal_check_overflow = 0;SELECT toDecimal32(4.2, 8) AS x, 6 * x", "SELECT toDecimal32(1, 8) < 100"], "Category": ["Numeric Data Types"]}
{"index": 10, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/boolean"], "Title": ["Bool"], "Feature": ["Bool"], "Description": ["Bool", "Type bool is internally stored as UInt8. Possible values are true (1), false (0).", "select true as col, toTypeName(col);\u250c\u2500col\u2500\u2500\u252c\u2500toTypeName(true)\u2500\u2510\u2502 true \u2502 Bool             \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518select true == 1 as col, toTypeName(col);\u250c\u2500col\u2500\u252c\u2500toTypeName(equals(true, 1))\u2500\u2510\u2502   1 \u2502 UInt8                       \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "CREATE TABLE test_bool(    `A` Int64,    `B` Bool)ENGINE = Memory;INSERT INTO test_bool VALUES (1, true),(2,0);SELECT * FROM test_bool;\u250c\u2500A\u2500\u252c\u2500B\u2500\u2500\u2500\u2500\u2500\u2510\u2502 1 \u2502 true  \u2502\u2502 2 \u2502 false \u2502\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"], "Examples": ["select true as col, toTypeName(col);\u250c\u2500col\u2500\u2500\u252c\u2500toTypeName(true)\u2500\u2510\u2502 true \u2502 Bool             \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518select true == 1 as col, toTypeName(col);\u250c\u2500col\u2500\u252c\u2500toTypeName(equals(true, 1))\u2500\u2510\u2502   1 \u2502 UInt8                       \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "CREATE TABLE test_bool(    `A` Int64,    `B` Bool)ENGINE = Memory;INSERT INTO test_bool VALUES (1, true),(2,0);SELECT * FROM test_bool;\u250c\u2500A\u2500\u252c\u2500B\u2500\u2500\u2500\u2500\u2500\u2510\u2502 1 \u2502 true  \u2502\u2502 2 \u2502 false \u2502\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"], "Category": ["Numeric Data Types"]}
