{"index": 15, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/array"], "Title": ["Array(T)"], "Feature": ["Array(T)"], "Description": ["Array(T)", "An array of T-type items, with the starting array index as 1. T can be any data type, including an array.", "Creating an Array\u200b", "You can use a function to create an array:", "array(T)", "You can also use square brackets.", "[]", "Example of creating an array:", "SELECT array(1, 2) AS x, toTypeName(x)", "\u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u252c\u2500toTypeName(array(1, 2))\u2500\u2510\u2502 [1,2] \u2502 Array(UInt8)            \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "SELECT [1, 2] AS x, toTypeName(x)", "\u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u252c\u2500toTypeName([1, 2])\u2500\u2510\u2502 [1,2] \u2502 Array(UInt8)       \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Working with Data Types\u200b", "When creating an array on the fly, ClickHouse automatically defines the argument type as the narrowest data type that can store all the listed arguments. If there are any Nullable or literal NULL values, the type of an array element also becomes Nullable.", "If ClickHouse couldn\u2019t determine the data type, it generates an exception. For instance, this happens when trying to create an array with strings and numbers simultaneously (SELECT array(1, 'a')).", "Examples of automatic data type detection:", "SELECT array(1, 2, NULL) AS x, toTypeName(x)", "\u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500toTypeName(array(1, 2, NULL))\u2500\u2510\u2502 [1,2,NULL] \u2502 Array(Nullable(UInt8))        \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "If you try to create an array of incompatible data types, ClickHouse throws an exception:", "SELECT array(1, 'a')", "Received exception from server (version 1.1.54388):Code: 386. DB::Exception: Received from localhost:9000, 127.0.0.1. DB::Exception: There is no supertype for types UInt8, String because some of them are String/FixedString and some of them are not.", "Array Size\u200b", "It is possible to find the size of an array by using the size0 subcolumn without reading the whole column. For multi-dimensional arrays you can use sizeN-1, where N is the wanted dimension.", "Example", "Query:", "CREATE TABLE t_arr (`arr` Array(Array(Array(UInt32)))) ENGINE = MergeTree ORDER BY tuple();INSERT INTO t_arr VALUES ([[[12, 13, 0, 1],[12]]]);SELECT arr.size0, arr.size1, arr.size2 FROM t_arr;", "Result:", "\u250c\u2500arr.size0\u2500\u252c\u2500arr.size1\u2500\u252c\u2500arr.size2\u2500\u2510\u2502         1 \u2502 [2]       \u2502 [[4,1]]   \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Reading nested subcolumns from Array\u200b", "If nested type T inside Array has subcolumns (for example, if it's a named tuple), you can read its subcolumns from an Array(T) type with the same subcolumn names. The type of a subcolumn will be Array of the type of original subcolumn.", "Example", "CREATE TABLE t_arr (arr Array(Tuple(field1 UInt32, field2 String))) ENGINE = MergeTree ORDER BY tuple();INSERT INTO t_arr VALUES ([(1, 'Hello'), (2, 'World')]), ([(3, 'This'), (4, 'is'), (5, 'subcolumn')]);SELECT arr.field1, toTypeName(arr.field1), arr.field2, toTypeName(arr.field2) from t_arr;", "\u250c\u2500arr.field1\u2500\u252c\u2500toTypeName(arr.field1)\u2500\u252c\u2500arr.field2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500toTypeName(arr.field2)\u2500\u2510\u2502 [1,2]      \u2502 Array(UInt32)          \u2502 ['Hello','World']         \u2502 Array(String)          \u2502\u2502 [3,4,5]    \u2502 Array(UInt32)          \u2502 ['This','is','subcolumn'] \u2502 Array(String)          \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"], "Examples": ["array(T)", "[]", "SELECT array(1, 2) AS x, toTypeName(x)", "SELECT [1, 2] AS x, toTypeName(x)", "SELECT array(1, 2, NULL) AS x, toTypeName(x)", "SELECT array(1, 'a')", "CREATE TABLE t_arr (`arr` Array(Array(Array(UInt32)))) ENGINE = MergeTree ORDER BY tuple();INSERT INTO t_arr VALUES ([[[12, 13, 0, 1],[12]]]);SELECT arr.size0, arr.size1, arr.size2 FROM t_arr;", "CREATE TABLE t_arr (arr Array(Tuple(field1 UInt32, field2 String))) ENGINE = MergeTree ORDER BY tuple();INSERT INTO t_arr VALUES ([(1, 'Hello'), (2, 'World')]), ([(3, 'This'), (4, 'is'), (5, 'subcolumn')]);SELECT arr.field1, toTypeName(arr.field1), arr.field2, toTypeName(arr.field2) from t_arr;"], "Category": ["Nested or Composite Data Types"]}
{"index": 16, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/tuple"], "Title": ["Tuple(T1, T2, ...)"], "Feature": ["Tuple(T1, T2, ...)"], "Description": ["Tuple(T1, T2, ...)", "A tuple of elements, each having an individual type. Tuple must contain at least one element.", "Tuples are used for temporary column grouping. Columns can be grouped when an IN expression is used in a query, and for specifying certain formal parameters of lambda functions. For more information, see the sections IN operators and Higher order functions.", "Tuples can be the result of a query. In this case, for text formats other than JSON, values are comma-separated in brackets. In JSON formats, tuples are output as arrays (in square brackets).", "Creating Tuples\u200b", "You can use a function to create a tuple:", "tuple(T1, T2, ...)", "Example of creating a tuple:", "SELECT tuple(1, 'a') AS x, toTypeName(x)", "\u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500toTypeName(tuple(1, 'a'))\u2500\u2510\u2502 (1,'a') \u2502 Tuple(UInt8, String)      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "A Tuple can contain a single element", "Example:", "SELECT tuple('a') AS x;", "\u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u2510\u2502 ('a') \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Syntax (tuple_element1, tuple_element2) may be used to create a tuple of several elements without calling the tuple() function.", "Example:", "SELECT (1, 'a') AS x, (today(), rand(), 'someString') AS y, ('a') AS not_a_tuple;", "\u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500y\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500not_a_tuple\u2500\u2510\u2502 (1,'a') \u2502 ('2022-09-21',2006973416,'someString') \u2502 a           \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Data Type Detection\u200b", "When creating tuples on the fly, ClickHouse interferes the type of the tuples arguments as the smallest types which can hold the provided argument value. If the value is NULL, the interfered type is Nullable.", "Example of automatic data type detection:", "SELECT tuple(1, NULL) AS x, toTypeName(x)", "\u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500toTypeName(tuple(1, NULL))\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 (1, NULL) \u2502 Tuple(UInt8, Nullable(Nothing)) \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Referring to Tuple Elements\u200b", "Tuple elements can be referred to by name or by index:", "CREATE TABLE named_tuples (`a` Tuple(s String, i Int64)) ENGINE = Memory;INSERT INTO named_tuples VALUES (('y', 10)), (('x',-10));SELECT a.s FROM named_tuples; -- by nameSELECT a.2 FROM named_tuples; -- by index", "Result:", "\u250c\u2500a.s\u2500\u2510\u2502 y   \u2502\u2502 x   \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500tupleElement(a, 2)\u2500\u2510\u2502                 10 \u2502\u2502                -10 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Comparison operations with Tuple\u200b", "Two tuples are compared by sequentially comparing their elements from the left to the right. If first tuples element is greater (smaller) than the second tuples corresponding element, then the first tuple is greater (smaller) than the second, otherwise (both elements are equal), the next element is compared.", "Example:", "SELECT (1, 'z') > (1, 'a') c1, (2022, 01, 02) > (2023, 04, 02) c2, (1,2,3) = (3,2,1) c3;", "\u250c\u2500c1\u2500\u252c\u2500c2\u2500\u252c\u2500c3\u2500\u2510\u2502  1 \u2502  0 \u2502  0 \u2502\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518", "Real world examples:", "CREATE TABLE test(    `year` Int16,    `month` Int8,    `day` Int8)ENGINE = Memory ASSELECT *FROM values((2022, 12, 31), (2000, 1, 1));SELECT * FROM test;\u250c\u2500year\u2500\u252c\u2500month\u2500\u252c\u2500day\u2500\u2510\u2502 2022 \u2502    12 \u2502  31 \u2502\u2502 2000 \u2502     1 \u2502   1 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518SELECT *FROM testWHERE (year, month, day) > (2010, 1, 1);\u250c\u2500year\u2500\u252c\u2500month\u2500\u252c\u2500day\u2500\u2510\u2502 2022 \u2502    12 \u2502  31 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518CREATE TABLE test(    `key` Int64,    `duration` UInt32,    `value` Float64)ENGINE = Memory ASSELECT *FROM values((1, 42, 66.5), (1, 42, 70), (2, 1, 10), (2, 2, 0));SELECT * FROM test;\u250c\u2500key\u2500\u252c\u2500duration\u2500\u252c\u2500value\u2500\u2510\u2502   1 \u2502       42 \u2502  66.5 \u2502\u2502   1 \u2502       42 \u2502    70 \u2502\u2502   2 \u2502        1 \u2502    10 \u2502\u2502   2 \u2502        2 \u2502     0 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518-- Let's find a value for each key with the biggest duration, if durations are equal, select the biggest valueSELECT    key,    max(duration),    argMax(value, (duration, value))FROM testGROUP BY keyORDER BY key ASC;\u250c\u2500key\u2500\u252c\u2500max(duration)\u2500\u252c\u2500argMax(value, tuple(duration, value))\u2500\u2510\u2502   1 \u2502            42 \u2502                                    70 \u2502\u2502   2 \u2502             2 \u2502                                     0 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"], "Examples": ["tuple(T1, T2, ...)", "SELECT tuple(1, 'a') AS x, toTypeName(x)", "SELECT tuple('a') AS x;", "SELECT (1, 'a') AS x, (today(), rand(), 'someString') AS y, ('a') AS not_a_tuple;", "SELECT tuple(1, NULL) AS x, toTypeName(x)", "CREATE TABLE named_tuples (`a` Tuple(s String, i Int64)) ENGINE = Memory;INSERT INTO named_tuples VALUES (('y', 10)), (('x',-10));SELECT a.s FROM named_tuples; -- by nameSELECT a.2 FROM named_tuples; -- by index", "SELECT (1, 'z') > (1, 'a') c1, (2022, 01, 02) > (2023, 04, 02) c2, (1,2,3) = (3,2,1) c3;", "CREATE TABLE test(    `year` Int16,    `month` Int8,    `day` Int8)ENGINE = Memory ASSELECT *FROM values((2022, 12, 31), (2000, 1, 1));SELECT * FROM test;\u250c\u2500year\u2500\u252c\u2500month\u2500\u252c\u2500day\u2500\u2510\u2502 2022 \u2502    12 \u2502  31 \u2502\u2502 2000 \u2502     1 \u2502   1 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518SELECT *FROM testWHERE (year, month, day) > (2010, 1, 1);\u250c\u2500year\u2500\u252c\u2500month\u2500\u252c\u2500day\u2500\u2510\u2502 2022 \u2502    12 \u2502  31 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518CREATE TABLE test(    `key` Int64,    `duration` UInt32,    `value` Float64)ENGINE = Memory ASSELECT *FROM values((1, 42, 66.5), (1, 42, 70), (2, 1, 10), (2, 2, 0));SELECT * FROM test;\u250c\u2500key\u2500\u252c\u2500duration\u2500\u252c\u2500value\u2500\u2510\u2502   1 \u2502       42 \u2502  66.5 \u2502\u2502   1 \u2502       42 \u2502    70 \u2502\u2502   2 \u2502        1 \u2502    10 \u2502\u2502   2 \u2502        2 \u2502     0 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518-- Let's find a value for each key with the biggest duration, if durations are equal, select the biggest valueSELECT    key,    max(duration),    argMax(value, (duration, value))FROM testGROUP BY keyORDER BY key ASC;\u250c\u2500key\u2500\u252c\u2500max(duration)\u2500\u252c\u2500argMax(value, tuple(duration, value))\u2500\u2510\u2502   1 \u2502            42 \u2502                                    70 \u2502\u2502   2 \u2502             2 \u2502                                     0 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"], "Category": ["Nested or Composite Data Types"]}
{"index": 17, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/map"], "Title": ["Map(K, V)"], "Feature": ["Map(K, V)"], "Description": ["Map(K, V)", "Data type Map(K, V) stores key-value pairs.", "Unlike other databases, maps are not unique in ClickHouse, i.e. a map can contain two elements with the same key.\n(The reason for that is that maps are internally implemented as Array(Tuple(K, V)).)", "You can use use syntax m[k] to obtain the value for key k in map m.\nAlso, m[k] scans the map, i.e. the runtime of the operation is linear in the size of the map.", "Parameters", "K \u2014 The type of the Map keys. Arbitrary type except Nullable and LowCardinality nested with Nullable types.V \u2014 The type of the Map values. Arbitrary type.", "Examples", "Create a table with a column of type map:", "CREATE TABLE tab (m Map(String, UInt64)) ENGINE=Memory;INSERT INTO tab VALUES ({'key1':1, 'key2':10}), ({'key1':2,'key2':20}), ({'key1':3,'key2':30});", "To select key2 values:", "SELECT m['key2'] FROM tab;", "Result:", "\u250c\u2500arrayElement(m, 'key2')\u2500\u2510\u2502                      10 \u2502\u2502                      20 \u2502\u2502                      30 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "If the requested key k is not contained in the map, m[k] returns the value type's default value, e.g. 0 for integer types and '' for string types.\nTo check whether a key exists in a map, you can use function mapContains.", "CREATE TABLE tab (m Map(String, UInt64)) ENGINE=Memory;INSERT INTO tab VALUES ({'key1':100}), ({});SELECT m['key1'] FROM tab;", "Result:", "\u250c\u2500arrayElement(m, 'key1')\u2500\u2510\u2502                     100 \u2502\u2502                       0 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Converting Tuple to Map\u200b", "Values of type Tuple() can be casted to values of type Map() using function CAST:", "Example", "Query:", "SELECT CAST(([1, 2, 3], ['Ready', 'Steady', 'Go']), 'Map(UInt8, String)') AS map;", "Result:", "\u250c\u2500map\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 {1:'Ready',2:'Steady',3:'Go'} \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Reading subcolumns of Map\u200b", "To avoid reading the entire map, you can use subcolumns keys and values in some cases.", "Example", "Query:", "CREATE TABLE tab (m Map(String, UInt64)) ENGINE = Memory;INSERT INTO tab VALUES (map('key1', 1, 'key2', 2, 'key3', 3));SELECT m.keys FROM tab; --   same as mapKeys(m)SELECT m.values FROM tab; -- same as mapValues(m)", "Result:", "\u250c\u2500m.keys\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 ['key1','key2','key3'] \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500m.values\u2500\u2510\u2502 [1,2,3]  \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "See Also", "map() functionCAST() function-Map combinator for Map datatype", "Related content\u200b", "Blog: Building an Observability Solution with ClickHouse - Part 2 - Traces"], "Examples": ["CREATE TABLE tab (m Map(String, UInt64)) ENGINE=Memory;INSERT INTO tab VALUES ({'key1':1, 'key2':10}), ({'key1':2,'key2':20}), ({'key1':3,'key2':30});", "SELECT m['key2'] FROM tab;", "CREATE TABLE tab (m Map(String, UInt64)) ENGINE=Memory;INSERT INTO tab VALUES ({'key1':100}), ({});SELECT m['key1'] FROM tab;", "SELECT CAST(([1, 2, 3], ['Ready', 'Steady', 'Go']), 'Map(UInt8, String)') AS map;", "CREATE TABLE tab (m Map(String, UInt64)) ENGINE = Memory;INSERT INTO tab VALUES (map('key1', 1, 'key2', 2, 'key3', 3));SELECT m.keys FROM tab; --   same as mapKeys(m)SELECT m.values FROM tab; -- same as mapValues(m)"], "Category": ["Nested or Composite Data Types"]}
{"index": 18, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/variant"], "Title": ["Variant(T1, T2, ...)"], "Feature": ["Variant(T1, T2, ...)"], "Description": ["Variant(T1, T2, ...)", "This type represents a union of other data types. Type Variant(T1, T2, ..., TN) means that each row of this type\nhas a value of either type T1 or T2 or ... or TN or none of them (NULL value).", "The order of nested types doesn't matter: Variant(T1, T2) = Variant(T2, T1).\nNested types can be arbitrary types except Nullable(...), LowCardinality(Nullable(...)) and Variant(...) types.", "NoteIt's not recommended to use similar types as variants (for example different numeric types like Variant(UInt32, Int64) or different date types like Variant(Date, DateTime)),\nbecause working with values of such types can lead to ambiguity. By default, creating such Variant type will lead to an exception, but can be enabled using setting allow_suspicious_variant_types", "NoteThe Variant data type is an experimental feature. To use it, set allow_experimental_variant_type = 1.", "Creating Variant\u200b", "Using Variant type in table column definition:", "CREATE TABLE test (v Variant(UInt64, String, Array(UInt64))) ENGINE = Memory;INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);SELECT v FROM test;", "\u250c\u2500v\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502\u2502 42            \u2502\u2502 Hello, World! \u2502\u2502 [1,2,3]       \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Using CAST from ordinary columns:", "SELECT toTypeName(variant) as type_name, 'Hello, World!'::Variant(UInt64, String, Array(UInt64)) as variant;", "\u250c\u2500type_name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500variant\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 Variant(Array(UInt64), String, UInt64) \u2502 Hello, World! \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Using functions if/multiIf when arguments don't have common type (setting use_variant_as_common_type should be enabled for it):", "SET use_variant_as_common_type = 1;SELECT if(number % 2, number, range(number)) as variant FROM numbers(5);", "\u250c\u2500variant\u2500\u2500\u2500\u2510\u2502 []        \u2502\u2502 1         \u2502\u2502 [0,1]     \u2502\u2502 3         \u2502\u2502 [0,1,2,3] \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "SET use_variant_as_common_type = 1;SELECT multiIf((number % 4) = 0, 42, (number % 4) = 1, [1, 2, 3], (number % 4) = 2, 'Hello, World!', NULL) AS variant FROM numbers(4);", "\u250c\u2500variant\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 42            \u2502\u2502 [1,2,3]       \u2502\u2502 Hello, World! \u2502\u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Using functions 'array/map' if array elements/map values don't have common type (setting use_variant_as_common_type should be enabled for it):", "SET use_variant_as_common_type = 1;SELECT array(range(number), number, 'str_' || toString(number)) as array_of_variants FROM numbers(3);", "\u250c\u2500array_of_variants\u2500\u2510\u2502 [[],0,'str_0']    \u2502\u2502 [[0],1,'str_1']   \u2502\u2502 [[0,1],2,'str_2'] \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "SET use_variant_as_common_type = 1;SELECT map('a', range(number), 'b', number, 'c', 'str_' || toString(number)) as map_of_variants FROM numbers(3);", "\u250c\u2500map_of_variants\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 {'a':[],'b':0,'c':'str_0'}    \u2502\u2502 {'a':[0],'b':1,'c':'str_1'}   \u2502\u2502 {'a':[0,1],'b':2,'c':'str_2'} \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Reading Variant nested types as subcolumns\u200b", "Variant type supports reading a single nested type from a Variant column using the type name as a subcolumn.\nSo, if you have column variant Variant(T1, T2, T3) you can read a subcolumn of type T2 using syntax variant.T2,\nthis subcolumn will have type Nullable(T2) if T2 can be inside Nullable and T2 otherwise. This subcolumn will\nbe the same size as original Variant column and will contain NULL values (or empty values if T2 cannot be inside Nullable)\nin all rows in which original Variant column doesn't have type T2.", "Variant subcolumns can be also read using function variantElement(variant_column, type_name). ", "Examples:", "CREATE TABLE test (v Variant(UInt64, String, Array(UInt64))) ENGINE = Memory;INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);SELECT v, v.String, v.UInt64, v.`Array(UInt64)` FROM test;", "\u250c\u2500v\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500v.String\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500v.UInt64\u2500\u252c\u2500v.Array(UInt64)\u2500\u2510\u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502     \u1d3a\u1d41\u1d38\u1d38 \u2502 []              \u2502\u2502 42            \u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502       42 \u2502 []              \u2502\u2502 Hello, World! \u2502 Hello, World! \u2502     \u1d3a\u1d41\u1d38\u1d38 \u2502 []              \u2502\u2502 [1,2,3]       \u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502     \u1d3a\u1d41\u1d38\u1d38 \u2502 [1,2,3]         \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "SELECT toTypeName(v.String), toTypeName(v.UInt64), toTypeName(v.`Array(UInt64)`) FROM test LIMIT 1;", "\u250c\u2500toTypeName(v.String)\u2500\u252c\u2500toTypeName(v.UInt64)\u2500\u252c\u2500toTypeName(v.Array(UInt64))\u2500\u2510\u2502 Nullable(String)     \u2502 Nullable(UInt64)     \u2502 Array(UInt64)               \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "SELECT v, variantElement(v, 'String'), variantElement(v, 'UInt64'), variantElement(v, 'Array(UInt64)') FROM test;", "\u250c\u2500v\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500variantElement(v, 'String')\u2500\u252c\u2500variantElement(v, 'UInt64')\u2500\u252c\u2500variantElement(v, 'Array(UInt64)')\u2500\u2510\u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502 \u1d3a\u1d41\u1d38\u1d38                        \u2502                        \u1d3a\u1d41\u1d38\u1d38 \u2502 []                                 \u2502\u2502 42            \u2502 \u1d3a\u1d41\u1d38\u1d38                        \u2502                          42 \u2502 []                                 \u2502\u2502 Hello, World! \u2502 Hello, World!               \u2502                        \u1d3a\u1d41\u1d38\u1d38 \u2502 []                                 \u2502\u2502 [1,2,3]       \u2502 \u1d3a\u1d41\u1d38\u1d38                        \u2502                        \u1d3a\u1d41\u1d38\u1d38 \u2502 [1,2,3]                            \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "To know what variant is stored in each row function variantType(variant_column) can be used. It returns Enum with variant type name for each row (or 'None' if row is NULL).", "Example:", "CREATE TABLE test (v Variant(UInt64, String, Array(UInt64))) ENGINE = Memory;INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);SELECT variantType(v) from test;", "\u250c\u2500variantType(v)\u2500\u2510\u2502 None           \u2502\u2502 UInt64         \u2502\u2502 String         \u2502\u2502 Array(UInt64)  \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "SELECT toTypeName(variantType(v)) FROM test LIMIT 1;", "\u250c\u2500toTypeName(variantType(v))\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 Enum8('None' = -1, 'Array(UInt64)' = 0, 'String' = 1, 'UInt64' = 2) \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Conversion between a Variant column and other columns\u200b", "There are 4 possible conversions that can be performed with a column of type Variant.", "Converting a String column to a Variant column\u200b", "Conversion from String to Variant is performed by parsing a value of Variant type from the string value:", "SELECT '42'::Variant(String, UInt64) as variant, variantType(variant) as variant_type", "\u250c\u2500variant\u2500\u252c\u2500variant_type\u2500\u2510\u2502 42      \u2502 UInt64       \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "SELECT '[1, 2, 3]'::Variant(String, Array(UInt64)) as variant, variantType(variant) as variant_type", "\u250c\u2500variant\u2500\u252c\u2500variant_type\u2500\u2500\u2510\u2502 [1,2,3] \u2502 Array(UInt64) \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "SELECT CAST(map('key1', '42', 'key2', 'true', 'key3', '2020-01-01'), 'Map(String, Variant(UInt64, Bool, Date))') as map_of_variants, mapApply((k, v) -> (k, variantType(v)), map_of_variants) as map_of_variant_types```", "\u250c\u2500map_of_variants\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500map_of_variant_types\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 {'key1':42,'key2':true,'key3':'2020-01-01'} \u2502 {'key1':'UInt64','key2':'Bool','key3':'Date'} \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Converting an ordinary column to a Variant column\u200b", "It is possible to convert an ordinary column with type T to a Variant column containing this type:", "SELECT toTypeName(variant) as type_name, [1,2,3]::Array(UInt64)::Variant(UInt64, String, Array(UInt64)) as variant, variantType(variant) as variant_name", "\u250c\u2500type_name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500variant\u2500\u252c\u2500variant_name\u2500\u2500\u2510\u2502 Variant(Array(UInt64), String, UInt64) \u2502 [1,2,3] \u2502 Array(UInt64) \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Note: converting from String type is always performed through parsing, if you need to convert String column to String variant of a Variant without parsing, you can do the following:", "SELECT '[1, 2, 3]'::Variant(String)::Variant(String, Array(UInt64), UInt64) as variant, variantType(variant) as variant_type", "\u250c\u2500variant\u2500\u2500\u2500\u252c\u2500variant_type\u2500\u2510\u2502 [1, 2, 3] \u2502 String       \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Converting a Variant column to an ordinary column\u200b", "It is possible to convert a Variant column to an ordinary column. In this case all nested variants will be converted to a destination type:", "CREATE TABLE test (v Variant(UInt64, String)) ENGINE = Memory;INSERT INTO test VALUES (NULL), (42), ('42.42');SELECT v::Nullable(Float64) FROM test;", "\u250c\u2500CAST(v, 'Nullable(Float64)')\u2500\u2510\u2502                         \u1d3a\u1d41\u1d38\u1d38 \u2502\u2502                           42 \u2502\u2502                        42.42 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Converting a Variant to another Variant\u200b", "It is possible to convert a Variant column to another Variant column, but only if the destination Variant column contains all nested types from the original Variant:", "CREATE TABLE test (v Variant(UInt64, String)) ENGINE = Memory;INSERT INTO test VALUES (NULL), (42), ('String');SELECT v::Variant(UInt64, String, Array(UInt64)) FROM test;", "\u250c\u2500CAST(v, 'Variant(UInt64, String, Array(UInt64))')\u2500\u2510\u2502 \u1d3a\u1d41\u1d38\u1d38                                              \u2502\u2502 42                                                \u2502\u2502 String                                            \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Reading Variant type from the data\u200b", "All text formats (TSV, CSV, CustomSeparated, Values, JSONEachRow, etc) supports reading Variant type. During data parsing ClickHouse tries to insert value into most appropriate variant type.", "Example:", "SELECT    v,    variantElement(v, 'String') AS str,    variantElement(v, 'UInt64') AS num,    variantElement(v, 'Float64') AS float,    variantElement(v, 'DateTime') AS date,    variantElement(v, 'Array(UInt64)') AS arrFROM format(JSONEachRow, 'v Variant(String, UInt64, Float64, DateTime, Array(UInt64))', $${\"v\" : \"Hello, World!\"},{\"v\" : 42},{\"v\" : 42.42},{\"v\" : \"2020-01-01 00:00:00\"},{\"v\" : [1, 2, 3]}$$)", "\u250c\u2500v\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500str\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500num\u2500\u252c\u2500float\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u252c\u2500arr\u2500\u2500\u2500\u2500\u2500\u2510\u2502 Hello, World!       \u2502 Hello, World! \u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502  \u1d3a\u1d41\u1d38\u1d38 \u2502                \u1d3a\u1d41\u1d38\u1d38 \u2502 []      \u2502\u2502 42                  \u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502   42 \u2502  \u1d3a\u1d41\u1d38\u1d38 \u2502                \u1d3a\u1d41\u1d38\u1d38 \u2502 []      \u2502\u2502 42.42               \u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502 42.42 \u2502                \u1d3a\u1d41\u1d38\u1d38 \u2502 []      \u2502\u2502 2020-01-01 00:00:00 \u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502  \u1d3a\u1d41\u1d38\u1d38 \u2502 2020-01-01 00:00:00 \u2502 []      \u2502\u2502 [1,2,3]             \u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502  \u1d3a\u1d41\u1d38\u1d38 \u2502                \u1d3a\u1d41\u1d38\u1d38 \u2502 [1,2,3] \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Comparing values of Variant type\u200b", "Values of a Variant type can be compared only with values with the same Variant type.", "The result of operator < for values v1 with underlying type T1 and v2 with underlying type T2  of a type Variant(..., T1, ... T2, ...) is defined as follows:", "If T1 = T2 = T, the result will be v1.T < v2.T (underlying values will be compared).If T1 != T2, the result will be T1 < T2 (type names will be compared).", "Examples:", "CREATE TABLE test (v1 Variant(String, UInt64, Array(UInt32)), v2 Variant(String, UInt64, Array(UInt32))) ENGINE=Memory;INSERT INTO test VALUES (42, 42), (42, 43), (42, 'abc'), (42, [1, 2, 3]), (42, []), (42, NULL);", "SELECT v2, variantType(v2) as v2_type from test order by v2;", "\u250c\u2500v2\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500v2_type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 []      \u2502 Array(UInt32) \u2502\u2502 [1,2,3] \u2502 Array(UInt32) \u2502\u2502 abc     \u2502 String        \u2502\u2502 42      \u2502 UInt64        \u2502\u2502 43      \u2502 UInt64        \u2502\u2502 \u1d3a\u1d41\u1d38\u1d38    \u2502 None          \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "SELECT v1, variantType(v1) as v1_type, v2, variantType(v2) as v2_type, v1 = v2, v1 < v2, v1 > v2 from test;", "\u250c\u2500v1\u2500\u252c\u2500v1_type\u2500\u252c\u2500v2\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500v2_type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500equals(v1, v2)\u2500\u252c\u2500less(v1, v2)\u2500\u252c\u2500greater(v1, v2)\u2500\u2510\u2502 42 \u2502 UInt64  \u2502 42      \u2502 UInt64        \u2502              1 \u2502            0 \u2502               0 \u2502\u2502 42 \u2502 UInt64  \u2502 43      \u2502 UInt64        \u2502              0 \u2502            1 \u2502               0 \u2502\u2502 42 \u2502 UInt64  \u2502 abc     \u2502 String        \u2502              0 \u2502            0 \u2502               1 \u2502\u2502 42 \u2502 UInt64  \u2502 [1,2,3] \u2502 Array(UInt32) \u2502              0 \u2502            0 \u2502               1 \u2502\u2502 42 \u2502 UInt64  \u2502 []      \u2502 Array(UInt32) \u2502              0 \u2502            0 \u2502               1 \u2502\u2502 42 \u2502 UInt64  \u2502 \u1d3a\u1d41\u1d38\u1d38    \u2502 None          \u2502              0 \u2502            1 \u2502               0 \u2502\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "If you need to find the row with specific Variant value, you can do one of the following:", "Cast value to the corresponding Variant type:", "SELECT * FROM test WHERE v2 == [1,2,3]::Array(UInt32)::Variant(String, UInt64, Array(UInt32));", "\u250c\u2500v1\u2500\u252c\u2500v2\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 42 \u2502 [1,2,3] \u2502\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Compare Variant subcolumn with required type:", "SELECT * FROM test WHERE v2.`Array(UInt32)` == [1,2,3] -- or using variantElement(v2, 'Array(UInt32)')", "\u250c\u2500v1\u2500\u252c\u2500v2\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 42 \u2502 [1,2,3] \u2502\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Sometimes it can be useful to make additional check on variant type as subcolumns with complex types like Array/Map/Tuple cannot be inside Nullable and will have default values instead of NULL on rows with different types:", "SELECT v2, v2.`Array(UInt32)`, variantType(v2) FROM test WHERE v2.`Array(UInt32)` == [];", "\u250c\u2500v2\u2500\u2500\u2500\u252c\u2500v2.Array(UInt32)\u2500\u252c\u2500variantType(v2)\u2500\u2510\u2502 42   \u2502 []               \u2502 UInt64          \u2502\u2502 43   \u2502 []               \u2502 UInt64          \u2502\u2502 abc  \u2502 []               \u2502 String          \u2502\u2502 []   \u2502 []               \u2502 Array(UInt32)   \u2502\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502 []               \u2502 None            \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "SELECT v2, v2.`Array(UInt32)`, variantType(v2) FROM test WHERE variantType(v2) == 'Array(UInt32)' AND v2.`Array(UInt32)` == [];", "\u250c\u2500v2\u2500\u252c\u2500v2.Array(UInt32)\u2500\u252c\u2500variantType(v2)\u2500\u2510\u2502 [] \u2502 []               \u2502 Array(UInt32)   \u2502\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Note: values of variants with different numeric types are considered as different variants and not compared between each other, their type names are compared instead.", "Example:", "SET allow_suspicious_variant_types = 1;CREATE TABLE test (v Variant(UInt32, Int64)) ENGINE=Memory;INSERT INTO test VALUES (1::UInt32), (1::Int64), (100::UInt32), (100::Int64);SELECT v, variantType(v) FROM test ORDER by v;", "\u250c\u2500v\u2500\u2500\u2500\u252c\u2500variantType(v)\u2500\u2510\u2502 1   \u2502 Int64          \u2502\u2502 100 \u2502 Int64          \u2502\u2502 1   \u2502 UInt32         \u2502\u2502 100 \u2502 UInt32         \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "Note by default Variant type is not allowed in GROUP BY/ORDER BY keys, if you want to use it consider its special comparison rule and enable allow_suspicious_types_in_group_by/allow_suspicious_types_in_order_by settings.", "JSONExtract functions with Variant\u200b", "All JSONExtract* functions support Variant type:", "SELECT JSONExtract('{\"a\" : [1, 2, 3]}', 'a', 'Variant(UInt32, String, Array(UInt32))') AS variant, variantType(variant) AS variant_type;", "\u250c\u2500variant\u2500\u252c\u2500variant_type\u2500\u2500\u2510\u2502 [1,2,3] \u2502 Array(UInt32) \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "SELECT JSONExtract('{\"obj\" : {\"a\" : 42, \"b\" : \"Hello\", \"c\" : [1,2,3]}}', 'obj', 'Map(String, Variant(UInt32, String, Array(UInt32)))') AS map_of_variants, mapApply((k, v) -> (k, variantType(v)), map_of_variants) AS map_of_variant_types", "\u250c\u2500map_of_variants\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500map_of_variant_types\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 {'a':42,'b':'Hello','c':[1,2,3]} \u2502 {'a':'UInt32','b':'String','c':'Array(UInt32)'} \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "SELECT JSONExtractKeysAndValues('{\"a\" : 42, \"b\" : \"Hello\", \"c\" : [1,2,3]}', 'Variant(UInt32, String, Array(UInt32))') AS variants, arrayMap(x -> (x.1, variantType(x.2)), variants) AS variant_types", "\u250c\u2500variants\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500variant_types\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 [('a',42),('b','Hello'),('c',[1,2,3])] \u2502 [('a','UInt32'),('b','String'),('c','Array(UInt32)')] \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"], "Examples": ["CREATE TABLE test (v Variant(UInt64, String, Array(UInt64))) ENGINE = Memory;INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);SELECT v FROM test;", "SELECT toTypeName(variant) as type_name, 'Hello, World!'::Variant(UInt64, String, Array(UInt64)) as variant;", "SET use_variant_as_common_type = 1;SELECT if(number % 2, number, range(number)) as variant FROM numbers(5);", "SET use_variant_as_common_type = 1;SELECT multiIf((number % 4) = 0, 42, (number % 4) = 1, [1, 2, 3], (number % 4) = 2, 'Hello, World!', NULL) AS variant FROM numbers(4);", "SET use_variant_as_common_type = 1;SELECT array(range(number), number, 'str_' || toString(number)) as array_of_variants FROM numbers(3);", "SET use_variant_as_common_type = 1;SELECT map('a', range(number), 'b', number, 'c', 'str_' || toString(number)) as map_of_variants FROM numbers(3);", "CREATE TABLE test (v Variant(UInt64, String, Array(UInt64))) ENGINE = Memory;INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);SELECT v, v.String, v.UInt64, v.`Array(UInt64)` FROM test;", "SELECT toTypeName(v.String), toTypeName(v.UInt64), toTypeName(v.`Array(UInt64)`) FROM test LIMIT 1;", "SELECT v, variantElement(v, 'String'), variantElement(v, 'UInt64'), variantElement(v, 'Array(UInt64)') FROM test;", "CREATE TABLE test (v Variant(UInt64, String, Array(UInt64))) ENGINE = Memory;INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);SELECT variantType(v) from test;", "SELECT toTypeName(variantType(v)) FROM test LIMIT 1;", "SELECT '42'::Variant(String, UInt64) as variant, variantType(variant) as variant_type", "SELECT '[1, 2, 3]'::Variant(String, Array(UInt64)) as variant, variantType(variant) as variant_type", "SELECT CAST(map('key1', '42', 'key2', 'true', 'key3', '2020-01-01'), 'Map(String, Variant(UInt64, Bool, Date))') as map_of_variants, mapApply((k, v) -> (k, variantType(v)), map_of_variants) as map_of_variant_types```", "SELECT toTypeName(variant) as type_name, [1,2,3]::Array(UInt64)::Variant(UInt64, String, Array(UInt64)) as variant, variantType(variant) as variant_name", "SELECT '[1, 2, 3]'::Variant(String)::Variant(String, Array(UInt64), UInt64) as variant, variantType(variant) as variant_type", "\u250c\u2500variant\u2500\u2500\u2500\u252c\u2500variant_type\u2500\u2510\u2502 [1, 2, 3] \u2502 String       \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "CREATE TABLE test (v Variant(UInt64, String)) ENGINE = Memory;INSERT INTO test VALUES (NULL), (42), ('42.42');SELECT v::Nullable(Float64) FROM test;", "CREATE TABLE test (v Variant(UInt64, String)) ENGINE = Memory;INSERT INTO test VALUES (NULL), (42), ('String');SELECT v::Variant(UInt64, String, Array(UInt64)) FROM test;", "SELECT    v,    variantElement(v, 'String') AS str,    variantElement(v, 'UInt64') AS num,    variantElement(v, 'Float64') AS float,    variantElement(v, 'DateTime') AS date,    variantElement(v, 'Array(UInt64)') AS arrFROM format(JSONEachRow, 'v Variant(String, UInt64, Float64, DateTime, Array(UInt64))', $${\"v\" : \"Hello, World!\"},{\"v\" : 42},{\"v\" : 42.42},{\"v\" : \"2020-01-01 00:00:00\"},{\"v\" : [1, 2, 3]}$$)", "CREATE TABLE test (v1 Variant(String, UInt64, Array(UInt32)), v2 Variant(String, UInt64, Array(UInt32))) ENGINE=Memory;INSERT INTO test VALUES (42, 42), (42, 43), (42, 'abc'), (42, [1, 2, 3]), (42, []), (42, NULL);", "SELECT v2, variantType(v2) as v2_type from test order by v2;", "SELECT v1, variantType(v1) as v1_type, v2, variantType(v2) as v2_type, v1 = v2, v1 < v2, v1 > v2 from test;", "SELECT * FROM test WHERE v2 == [1,2,3]::Array(UInt32)::Variant(String, UInt64, Array(UInt32));", "SELECT * FROM test WHERE v2.`Array(UInt32)` == [1,2,3] -- or using variantElement(v2, 'Array(UInt32)')", "SELECT v2, v2.`Array(UInt32)`, variantType(v2) FROM test WHERE v2.`Array(UInt32)` == [];", "SELECT v2, v2.`Array(UInt32)`, variantType(v2) FROM test WHERE variantType(v2) == 'Array(UInt32)' AND v2.`Array(UInt32)` == [];", "SET allow_suspicious_variant_types = 1;CREATE TABLE test (v Variant(UInt32, Int64)) ENGINE=Memory;INSERT INTO test VALUES (1::UInt32), (1::Int64), (100::UInt32), (100::Int64);SELECT v, variantType(v) FROM test ORDER by v;", "SELECT JSONExtract('{\"a\" : [1, 2, 3]}', 'a', 'Variant(UInt32, String, Array(UInt32))') AS variant, variantType(variant) AS variant_type;", "SELECT JSONExtract('{\"obj\" : {\"a\" : 42, \"b\" : \"Hello\", \"c\" : [1,2,3]}}', 'obj', 'Map(String, Variant(UInt32, String, Array(UInt32)))') AS map_of_variants, mapApply((k, v) -> (k, variantType(v)), map_of_variants) AS map_of_variant_types", "SELECT JSONExtractKeysAndValues('{\"a\" : 42, \"b\" : \"Hello\", \"c\" : [1,2,3]}', 'Variant(UInt32, String, Array(UInt32))') AS variants, arrayMap(x -> (x.1, variantType(x.2)), variants) AS variant_types"], "Category": ["Nested or Composite Data Types"]}
{"index": 19, "HTML": ["https://clickhouse.com/docs/en/sql-reference/data-types/nested-data-structures/nested"], "Title": ["Nested(Name1 Type1, Name2 Type2, ...)"], "Feature": ["Nested(Name1 Type1, Name2 Type2, ...)"], "Description": ["Nested", "Nested(name1 Type1, Name2 Type2, ...)\u200b", "A nested data structure is like a table inside a cell. The parameters of a nested data structure \u2013 the column names and types \u2013 are specified the same way as in a CREATE TABLE query. Each table row can correspond to any number of rows in a nested data structure.", "Example:", "CREATE TABLE test.visits(    CounterID UInt32,    StartDate Date,    Sign Int8,    IsNew UInt8,    VisitID UInt64,    UserID UInt64,    ...    Goals Nested    (        ID UInt32,        Serial UInt32,        EventTime DateTime,        Price Int64,        OrderID String,        CurrencyID UInt32    ),    ...) ENGINE = CollapsingMergeTree(StartDate, intHash32(UserID), (CounterID, StartDate, intHash32(UserID), VisitID), 8192, Sign)", "This example declares the Goals nested data structure, which contains data about conversions (goals reached). Each row in the \u2018visits\u2019 table can correspond to zero or any number of conversions.", "When flatten_nested is set to 0 (which is not by default), arbitrary levels of nesting are supported.", "In most cases, when working with a nested data structure, its columns are specified with column names separated by a dot. These columns make up an array of matching types. All the column arrays of a single nested data structure have the same length.", "Example:", "SELECT    Goals.ID,    Goals.EventTimeFROM test.visitsWHERE CounterID = 101500 AND length(Goals.ID) < 5LIMIT 10", "\u250c\u2500Goals.ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500Goals.EventTime\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502 [1073752,591325,591325]        \u2502 ['2014-03-17 16:38:10','2014-03-17 16:38:48','2014-03-17 16:42:27']                       \u2502\u2502 [1073752]                      \u2502 ['2014-03-17 00:28:25']                                                                   \u2502\u2502 [1073752]                      \u2502 ['2014-03-17 10:46:20']                                                                   \u2502\u2502 [1073752,591325,591325,591325] \u2502 ['2014-03-17 13:59:20','2014-03-17 22:17:55','2014-03-17 22:18:07','2014-03-17 22:18:51'] \u2502\u2502 []                             \u2502 []                                                                                        \u2502\u2502 [1073752,591325,591325]        \u2502 ['2014-03-17 11:37:06','2014-03-17 14:07:47','2014-03-17 14:36:21']                       \u2502\u2502 []                             \u2502 []                                                                                        \u2502\u2502 []                             \u2502 []                                                                                        \u2502\u2502 [591325,1073752]               \u2502 ['2014-03-17 00:46:05','2014-03-17 00:46:05']                                             \u2502\u2502 [1073752,591325,591325,591325] \u2502 ['2014-03-17 13:28:33','2014-03-17 13:30:26','2014-03-17 18:51:21','2014-03-17 18:51:45'] \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "It is easiest to think of a nested data structure as a set of multiple column arrays of the same length.", "The only place where a SELECT query can specify the name of an entire nested data structure instead of individual columns is the ARRAY JOIN clause. For more information, see \u201cARRAY JOIN clause\u201d. Example:", "SELECT    Goal.ID,    Goal.EventTimeFROM test.visitsARRAY JOIN Goals AS GoalWHERE CounterID = 101500 AND length(Goals.ID) < 5LIMIT 10", "\u250c\u2500Goal.ID\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500Goal.EventTime\u2500\u2510\u2502 1073752 \u2502 2014-03-17 16:38:10 \u2502\u2502  591325 \u2502 2014-03-17 16:38:48 \u2502\u2502  591325 \u2502 2014-03-17 16:42:27 \u2502\u2502 1073752 \u2502 2014-03-17 00:28:25 \u2502\u2502 1073752 \u2502 2014-03-17 10:46:20 \u2502\u2502 1073752 \u2502 2014-03-17 13:59:20 \u2502\u2502  591325 \u2502 2014-03-17 22:17:55 \u2502\u2502  591325 \u2502 2014-03-17 22:18:07 \u2502\u2502  591325 \u2502 2014-03-17 22:18:51 \u2502\u2502 1073752 \u2502 2014-03-17 11:37:06 \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "You can\u2019t perform SELECT for an entire nested data structure. You can only explicitly list individual columns that are part of it.", "For an INSERT query, you should pass all the component column arrays of a nested data structure separately (as if they were individual column arrays). During insertion, the system checks that they have the same length.", "For a DESCRIBE query, the columns in a nested data structure are listed separately in the same way.", "The ALTER query for elements in a nested data structure has limitations."], "Examples": ["CREATE TABLE test.visits(    CounterID UInt32,    StartDate Date,    Sign Int8,    IsNew UInt8,    VisitID UInt64,    UserID UInt64,    ...    Goals Nested    (        ID UInt32,        Serial UInt32,        EventTime DateTime,        Price Int64,        OrderID String,        CurrencyID UInt32    ),    ...) ENGINE = CollapsingMergeTree(StartDate, intHash32(UserID), (CounterID, StartDate, intHash32(UserID), VisitID), 8192, Sign)", "SELECT    Goals.ID,    Goals.EventTimeFROM test.visitsWHERE CounterID = 101500 AND length(Goals.ID) < 5LIMIT 10", "SELECT    Goal.ID,    Goal.EventTimeFROM test.visitsARRAY JOIN Goals AS GoalWHERE CounterID = 101500 AND length(Goals.ID) < 5LIMIT 10"], "Category": ["Nested or Composite Data Types"]}
{"index": 20, "HTML": ["https://clickhouse.com/docs/sql-reference/data-types/qbit"], "Title": ["QBit Data Type"], "Feature": ["column_name QBit(element_type, dimension)"], "Description": ["The QBit data type reorganizes vector storage for faster approximate searches. Instead of storing each vector's elements together, it groups the same binary digit positions across all vectors. This stores vectors at full precision while letting you choose the fine-grained quantization level at search time: read fewer bits for less I/O and faster calculations, or more bits for higher accuracy. You get the speed benefits of reduced data transfer and computation from quantization, but all the original data remains available when needed", "Note\nQBit data type and distance functions associated with it are currently experimental. To enable them, please first run SET allow_experimental_qbit_type = 1. If you run into problems, kindly open an issue in the ClickHouse repository.", "To declare a column of QBit type, use the following syntax:", "column_name QBit(element_type, dimension)", "element_type \u2013 the type of each vector element. The allowed types are BFloat16, Float32 and Float64\ndimension \u2013 the number of elements in each vector"], "Examples": ["CREATE TABLE test (id UInt32, vec QBit(Float32, 8)) ENGINE = Memory;\nINSERT INTO test VALUES (1, [1, 2, 3, 4, 5, 6, 7, 8]), (2, [9, 10, 11, 12, 13, 14, 15, 16]);\nSELECT vec FROM test ORDER BY id;", "CREATE TABLE test (id UInt32, vec QBit(Float32, 8)) ENGINE = Memory;\nINSERT INTO test VALUES (1, [0, 0, 0, 0, 0, 0, 0, 0]);\nINSERT INTO test VALUES (1, [-0, -0, -0, -0, -0, -0, -0, -0]);\nSELECT bin(vec.1) FROM test;"], "Category": ["Nested or Composite Data Types"]}
