{"index": 11, "HTML": ["https://www.postgresql.org/docs/16/datatype-character.html"], "Title": ["character varying(n), varchar(n)"], "Feature": ["character varying(n), varchar(n)"], "Description": ["Description", "variable-length with limit"], "Examples": [], "Category": ["String Data Types"]}
{"index": 12, "HTML": ["https://www.postgresql.org/docs/16/datatype-character.html"], "Title": ["character(n), char(n), bpchar(n)"], "Feature": ["character(n), char(n), bpchar(n)"], "Description": ["Description", "fixed-length, blank-padded"], "Examples": [], "Category": ["String Data Types"]}
{"index": 13, "HTML": ["https://www.postgresql.org/docs/16/datatype-character.html"], "Title": ["bpchar"], "Feature": ["bpchar"], "Description": ["Description", "variable unlimited length, blank-trimmed"], "Examples": [], "Category": ["String Data Types"]}
{"index": 14, "HTML": ["https://www.postgresql.org/docs/16/datatype-character.html"], "Title": ["text"], "Feature": ["text"], "Description": ["Description", "variable unlimited length"], "Examples": [], "Category": ["String Data Types"]}
{"index": 15, "HTML": ["https://www.postgresql.org/docs/16/datatype-binary.html"], "Title": ["bytea"], "Feature": ["bytea"], "Description": ["Storage Size", "1 or 4 bytes plus the actual binary string", "Description", "variable-length binary string"], "Examples": [], "Category": ["String Data Types"]}
{"index": 23, "HTML": ["https://www.postgresql.org/docs/16/datatype-enum.html"], "Title": ["8.7. Enumerated Types"], "Feature": ["Enum"], "Description": ["\n\n\n8.7.\u00a0Enumerated Types #\n\n\n", "\n\n8.7.1. Declaration of Enumerated Types\n8.7.2. Ordering\n8.7.3. Type Safety\n8.7.4. Implementation Details\n\n", "Enumerated (enum) types are data types that comprise a static, ordered set of values. They are equivalent to the enum types supported in a number of programming languages. An example of an enum type might be the days of the week, or a set of status values for a piece of data.", "\n\n\n\n8.7.1.\u00a0Declaration of Enumerated Types #\n\n\n\nEnum types are created using the CREATE TYPE command, for example:\nCREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');\n\nOnce created, the enum type can be used in table and function definitions much like any other type:\nCREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');\nCREATE TABLE person (\n    name text,\n    current_mood mood\n);\nINSERT INTO person VALUES ('Moe', 'happy');\nSELECT * FROM person WHERE current_mood = 'happy';\n name | current_mood\n------+--------------\n Moe  | happy\n(1 row)\n\n", "\n\n\n\n8.7.2.\u00a0Ordering #\n\n\n\nThe ordering of the values in an enum type is the order in which the values were listed when the type was created. All standard comparison operators and related aggregate functions are supported for enums. For example:\nINSERT INTO person VALUES ('Larry', 'sad');\nINSERT INTO person VALUES ('Curly', 'ok');\nSELECT * FROM person WHERE current_mood > 'sad';\n name  | current_mood\n-------+--------------\n Moe   | happy\n Curly | ok\n(2 rows)\n\nSELECT * FROM person WHERE current_mood > 'sad' ORDER BY current_mood;\n name  | current_mood\n-------+--------------\n Curly | ok\n Moe   | happy\n(2 rows)\n\nSELECT name\nFROM person\nWHERE current_mood = (SELECT MIN(current_mood) FROM person);\n name\n-------\n Larry\n(1 row)\n\n", "\n\n\n\n8.7.3.\u00a0Type Safety #\n\n\n\nEach enumerated data type is separate and cannot be compared with other enumerated types. See this example:\nCREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');\nCREATE TABLE holidays (\n    num_weeks integer,\n    happiness happiness\n);\nINSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');\nINSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');\nINSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');\nINSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');\nERROR:  invalid input value for enum happiness: \"sad\"\nSELECT person.name, holidays.num_weeks FROM person, holidays\n  WHERE person.current_mood = holidays.happiness;\nERROR:  operator does not exist: mood = happiness\n\nIf you really need to do something like that, you can either write a custom operator or add explicit casts to your query:\nSELECT person.name, holidays.num_weeks FROM person, holidays\n  WHERE person.current_mood::text = holidays.happiness::text;\n name | num_weeks\n------+-----------\n Moe  |         4\n(1 row)\n\n\n", "\n\n\n\n8.7.4.\u00a0Implementation Details #\n\n\n\nEnum labels are case sensitive, so 'happy' is not the same as 'HAPPY'. White space in the labels is significant too.\nAlthough enum types are primarily intended for static sets of values, there is support for adding new values to an existing enum type, and for renaming values (see ALTER TYPE). Existing values cannot be removed from an enum type, nor can the sort ordering of such values be changed, short of dropping and re-creating the enum type.\nAn enum value occupies four bytes on disk. The length of an enum value's textual label is limited by the NAMEDATALEN setting compiled into PostgreSQL; in standard builds this means at most 63 bytes.\nThe translations from internal enum values to textual labels are kept in the system catalog pg_enum. Querying this catalog directly can be useful.\n"], "Examples": [], "Category": ["String Data Types"]}
{"index": 38, "HTML": ["https://www.postgresql.org/docs/16/datatype-textsearch.html"], "Title": ["8.11. Text Search Types"], "Feature": ["tsvector"], "Description": ["\n\n\n8.11.\u00a0Text Search Types #\n\n\n", "PostgreSQL provides two data types that are designed to support full text search, which is the activity of searching through a collection of natural-language documents to locate those that best match a query. The tsvector type represents a document in a form optimized for text search; the tsquery type similarly represents a text query. Chapter\u00a012 provides a detailed explanation of this facility, and Section\u00a09.13 summarizes the related functions and operators.", "\n\n\n\n8.11.1.\u00a0tsvector #\n\n\n\nA tsvector value is a sorted list of distinct lexemes, which are words that have been normalized to merge different variants of the same word (see Chapter\u00a012 for details). Sorting and duplicate-elimination are done automatically during input, as shown in this example:\nSELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;\n                      tsvector\n----------------------------------------------------\n 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'\n\nTo represent lexemes containing whitespace or punctuation, surround them with quotes:\nSELECT $$the lexeme '    ' contains spaces$$::tsvector;\n                 tsvector\n-------------------------------------------\n '    ' 'contains' 'lexeme' 'spaces' 'the'\n\n(We use dollar-quoted string literals in this example and the next one to avoid the confusion of having to double quote marks within the literals.) Embedded quotes and backslashes must be doubled:\nSELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;\n                    tsvector\n------------------------------------------------\n 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'\n\nOptionally, integer positions can be attached to lexemes:\nSELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;\n                                  tsvector\n-------------------------------------------------------------------\u200b------------\n 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4\n\nA position normally indicates the source word's location in the document. Positional information can be used for proximity ranking. Position values can range from 1 to 16383; larger numbers are silently set to 16383. Duplicate positions for the same lexeme are discarded.\nLexemes that have positions can further be labeled with a weight, which can be A, B, C, or D. D is the default and hence is not shown on output:\nSELECT 'a:1A fat:2B,4C cat:5D'::tsvector;\n          tsvector\n----------------------------\n 'a':1A 'cat':5 'fat':2B,4C\n\nWeights are typically used to reflect document structure, for example by marking title words differently from body words. Text search ranking functions can assign different priorities to the different weight markers.\nIt is important to understand that the tsvector type itself does not perform any word normalization; it assumes the words it is given are normalized appropriately for the application. For example,\nSELECT 'The Fat Rats'::tsvector;\n      tsvector\n--------------------\n 'Fat' 'Rats' 'The'\n\nFor most English-text-searching applications the above words would be considered non-normalized, but tsvector doesn't care. Raw document text should usually be passed through to_tsvector to normalize the words appropriately for searching:\nSELECT to_tsvector('english', 'The Fat Rats');\n   to_tsvector\n-----------------\n 'fat':2 'rat':3\n\nAgain, see Chapter\u00a012 for more detail.\n"], "Examples": ["SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;", "SELECT $$the lexeme '    ' contains spaces$$::tsvector;", "SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;", "SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;", "SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;", "SELECT 'The Fat Rats'::tsvector;", "SELECT to_tsvector('english', 'The Fat Rats');"], "Category": ["String Data Types"]}
{"index": 39, "HTML": ["https://www.postgresql.org/docs/16/datatype-textsearch.html"], "Title": ["8.11. Text Search Types"], "Feature": ["tsquery"], "Description": ["\n\n\n8.11.\u00a0Text Search Types #\n\n\n", "PostgreSQL provides two data types that are designed to support full text search, which is the activity of searching through a collection of natural-language documents to locate those that best match a query. The tsvector type represents a document in a form optimized for text search; the tsquery type similarly represents a text query. Chapter\u00a012 provides a detailed explanation of this facility, and Section\u00a09.13 summarizes the related functions and operators.", "\n\n\n\n8.11.2.\u00a0tsquery #\n\n\n\nA tsquery value stores lexemes that are to be searched for, and can combine them using the Boolean operators & (AND), | (OR), and ! (NOT), as well as the phrase search operator <-> (FOLLOWED BY). There is also a variant <N> of the FOLLOWED BY operator, where N is an integer constant that specifies the distance between the two lexemes being searched for. <-> is equivalent to <1>.\nParentheses can be used to enforce grouping of these operators. In the absence of parentheses, ! (NOT) binds most tightly, <-> (FOLLOWED BY) next most tightly, then & (AND), with | (OR) binding the least tightly.\nHere are some examples:\nSELECT 'fat & rat'::tsquery;\n    tsquery\n---------------\n 'fat' & 'rat'\n\nSELECT 'fat & (rat | cat)'::tsquery;\n          tsquery\n---------------------------\n 'fat' & ( 'rat' | 'cat' )\n\nSELECT 'fat & rat & ! cat'::tsquery;\n        tsquery\n------------------------\n 'fat' & 'rat' & !'cat'\n\nOptionally, lexemes in a tsquery can be labeled with one or more weight letters, which restricts them to match only tsvector lexemes with one of those weights:\nSELECT 'fat:ab & cat'::tsquery;\n    tsquery\n------------------\n 'fat':AB & 'cat'\n\nAlso, lexemes in a tsquery can be labeled with * to specify prefix matching:\nSELECT 'super:*'::tsquery;\n  tsquery\n-----------\n 'super':*\n\nThis query will match any word in a tsvector that begins with \u201csuper\u201d.\nQuoting rules for lexemes are the same as described previously for lexemes in tsvector; and, as with tsvector, any required normalization of words must be done before converting to the tsquery type. The to_tsquery function is convenient for performing such normalization:\nSELECT to_tsquery('Fat:ab & Cats');\n    to_tsquery\n------------------\n 'fat':AB & 'cat'\n\nNote that to_tsquery will process prefixes in the same way as other words, which means this comparison returns true:\nSELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );\n ?column?\n----------\n t\n\nbecause postgres gets stemmed to postgr:\nSELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );\n  to_tsvector  | to_tsquery\n---------------+------------\n 'postgradu':1 | 'postgr':*\n\nwhich will match the stemmed form of postgraduate.\n"], "Examples": ["SELECT 'fat & rat'::tsquery;", "SELECT 'fat & (rat | cat)'::tsquery;", "SELECT 'fat & rat & ! cat'::tsquery;", "SELECT 'fat:ab & cat'::tsquery;", "SELECT 'super:*'::tsquery;", "SELECT to_tsquery('Fat:ab & Cats');", "SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );", "SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );"], "Category": ["String Data Types"]}
